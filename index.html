<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pico OLED UI Editor</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        #editor-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        #canvas-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #display-canvas {
            border: 1px solid #333;
            background-color: #000; /* Simulate OLED black background */
            image-rendering: optimizePixed; /* Keep pixels sharp */
            image-rendering: pixelated;
            width: 512px; /* Scaled up for visibility (128 * 4) */
            height: 256px; /* Scaled up for visibility (64 * 4) */
            cursor: crosshair;
        }
        #mouse-coords {
            margin-top: 5px;
            font-size: 0.9em;
            color: #555;
        }
        #controls-area {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .tool-bar, .properties-panel, .animation-panel, .sprite-editor-panel {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        .tool-bar h3, .properties-panel h3, .animation-panel h3, .sprite-editor-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .tool-bar button, .properties-panel button, .animation-panel button, #sprite-editor button {
            margin: 2px;
            padding: 8px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #eee;
            border-radius: 3px;
        }
        .tool-bar button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .properties-panel div, .animation-panel div, #sprite-editor label {
            margin-bottom: 10px;
        }
        .properties-panel input[type="number"],
        .properties-panel input[type="text"],
        .properties-panel select,
        .animation-panel input[type="number"] {
            width: calc(100% - 12px);
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .properties-panel input[type="checkbox"] {
            margin-right: 5px;
        }

        #code-output-area {
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        #generated-code {
            width: calc(100% - 20px);
            height: 300px;
            border: 1px solid #ccc;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            overflow: auto;
            background-color: #f9f9f9;
        }

        /* Sprite Editor Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover, .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        #sprite-editor-grid {
            display: grid;
            border: 1px solid #ccc;
            margin: 10px auto;
        }
        #sprite-editor-grid .pixel {
            width: 15px;
            height: 15px;
            border: 1px solid #eee;
            background-color: white; /* White represents off */
        }
        #sprite-editor-grid .pixel.on {
            background-color: black; /* Black represents on */
        }
        #sprite-editor-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
         .grid-option {
             margin-bottom: 10px;
         }
         .grid-option input {
             margin-left: 5px;
         }
         .element-list-item {
             padding: 5px;
             border-bottom: 1px solid #eee;
             cursor: pointer;
         }
        .element-list-item.selected {
            background-color: #e0f2ff;
        }
        #element-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 3px;
        }

    </style>
</head>
<body>

    <h1>Pico OLED UI Editor (128x64)</h1>

    <div id="editor-container">
        <div id="canvas-area">
            <canvas id="display-canvas" width="128" height="64"></canvas>
            <div id="mouse-coords">(0, 0)</div>
            <div class="grid-option">
                <label for="show-grid">Show Grid</label>
                <input type="checkbox" id="show-grid">
                <label for="snap-grid">Snap to Grid</label>
                <input type="checkbox" id="snap-grid">
            </div>
        </div>

        <div id="controls-area">
            <div class="tool-bar">
                <h3>Tools</h3>
                <button id="tool-select" class="active">Select</button>
                <button id="tool-pixel">Pixel</button>
                <button id="tool-line">Line</button>
                <button id="tool-rect">Rect</button>
                <button id="tool-filled-rect">Filled Rect</button>
                <button id="tool-circle">Circle</button>
                <button id="tool-filled-circle">Filled Circle</button>
                <button id="tool-text">Text</button>
                <button id="tool-sprite">Sprite</button>
                 <button id="tool-eraser">Eraser</button>
            </div>

             <div class="properties-panel">
                <h3>Element Properties</h3>
                 <div id="no-element-selected">Select an element to see properties.</div>
                <div id="selected-element-properties" style="display: none;">
                    <div>
                        <label for="prop-type">Type:</label>
                        <span id="prop-type"></span>
                    </div>
                     <div>
                        <label for="prop-x">X:</label>
                        <input type="number" id="prop-x" value="0">
                    </div>
                    <div>
                        <label for="prop-y">Y:</label>
                        <input type="number" id="prop-y" value="0">
                    </div>
                     <div class="prop-text">
                        <label for="prop-text-content">Text:</label>
                        <input type="text" id="prop-text-content" value="">
                     </div>
                     <div class="prop-size">
                        <label for="prop-width">Width:</label>
                        <input type="number" id="prop-width" value="10">
                    </div>
                    <div class="prop-size">
                        <label for="prop-height">Height:</label>
                        <input type="number" id="prop-height" value="10">
                    </div>
                     <div class="prop-radius">
                        <label for="prop-radius">Radius:</label>
                        <input type="number" id="prop-radius" value="5">
                     </div>
                    <div class="prop-color">
                         <label for="prop-color">Color:</label>
                        <select id="prop-color">
                            <option value="1">On (Black/White)</option>
                            <option value="0">Off (White/Black)</option>
                        </select>
                     </div>
                    <div class="prop-fill">
                        <label for="prop-fill">Filled:</label>
                        <input type="checkbox" id="prop-fill">
                    </div>
                     <div class="prop-sprite">
                         <label>Sprite:</label>
                         <button id="edit-sprite-button">Edit Sprite Data</button>
                     </div>
                     <button id="delete-element-button" style="background-color: #dc3545; color: white; border-color: #dc3545;">Delete Element</button>
                </div>
            </div>

            <div class="animation-panel">
                 <h3>Animation (Preview Only)</h3>
                <div id="no-anim-element-selected">Select an element to add animation.</div>
                 <div id="selected-anim-controls" style="display: none;">
                     <p>Define a simple path animation (start = current pos)</p>
                     <div>
                         <label for="anim-end-x">End X:</label>
                         <input type="number" id="anim-end-x" value="0">
                     </div>
                     <div>
                         <label for="anim-end-y">End Y:</label>
                         <input type="number" id="anim-end-y" value="0">
                     </div>
                     <div>
                         <label for="anim-steps">Steps:</label>
                         <input type="number" id="anim-steps" value="50" min="1">
                     </div>
                     <button id="add-animation-button">Set Animation</button>
                     <button id="remove-animation-button" style="background-color: #ffc107; border-color: #ffc107;">Remove Animation</button>
                     <button id="play-animation-button" style="background-color: #28a745; color: white; border-color: #28a745;">Play Animation</button>
                     <button id="stop-animation-button" style="background-color: #dc3545; color: white; border-color: #dc3545;">Stop Animation</button>
                 </div>
             </div>

             <div class="properties-panel">
                 <h3>Layers</h3>
                 <div id="element-list">
                     <!-- Element list will be populated here -->
                 </div>
                 <button id="move-up-button">Move Up</button>
                 <button id="move-down-button">Move Down</button>
             </div>

            <div class="tool-bar">
                <h3>Code</h3>
                <button id="generate-code-button">Generate MicroPython Code</button>
            </div>
        </div>
    </div>

    <div id="code-output-area">
        <h2>Generated MicroPython Code</h2>
        <pre id="generated-code"></pre>
    </div>

    <!-- Sprite Editor Modal -->
    <div id="spriteEditorModal" class="modal">
        <div class="modal-content">
            <span class="close">Ã—</span>
            <h3>Sprite Editor (<span id="current-sprite-name">New Sprite</span>)</h3>
            <div>
                <label for="sprite-width">Width:</label>
                <input type="number" id="sprite-editor-width" value="8" min="1" max="32">
                <label for="sprite-height" style="margin-left: 10px;">Height:</label>
                <input type="number" id="sprite-editor-height" value="8" min="1" max="32">
                <button id="resize-sprite-grid">Resize Grid</button>
            </div>
            <div id="sprite-editor-grid">
                <!-- Pixel grid will be generated here -->
            </div>
            <div id="sprite-editor-controls">
                <button id="new-sprite-button">New Sprite</button>
                 <label for="sprite-name">Name:</label>
                 <input type="text" id="sprite-name" value="new_sprite">
                <button id="save-sprite-button">Save Sprite</button>
                <select id="sprite-library-select">
                    <option value="">-- Load Sprite --</option>
                </select>
                 <button id="load-sprite-button">Load Selected</button>
            </div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const DISPLAY_WIDTH = 128;
        const DISPLAY_HEIGHT = 64;
        const SCALE = 4; // For canvas display size
        const GRID_SIZE = 8; // Grid snap size

        // --- DOM Elements ---
        const canvas = document.getElementById('display-canvas');
        const ctx = canvas.getContext('2d');
        const mouseCoordsDiv = document.getElementById('mouse-coords');
        const toolButtons = document.querySelectorAll('.tool-bar button');
        const propertiesPanel = document.getElementById('selected-element-properties');
        const noElementSelectedMsg = document.getElementById('no-element-selected');
        const propTypeSpan = document.getElementById('prop-type');
        const propXInput = document.getElementById('prop-x');
        const propYInput = document.getElementById('prop-y');
        const propTextDiv = document.querySelector('.prop-text');
        const propTextContentInput = document.getElementById('prop-text-content');
        const propSizeDivs = document.querySelectorAll('.prop-size');
        const propWidthInput = document.getElementById('prop-width');
        const propHeightInput = document.getElementById('prop-height');
        const propRadiusDiv = document.querySelector('.prop-radius');
        const propRadiusInput = document.getElementById('prop-radius');
        const propColorDiv = document.querySelector('.prop-color');
        const propColorSelect = document.getElementById('prop-color');
        const propFillDiv = document.querySelector('.prop-fill');
        const propFillCheckbox = document.getElementById('prop-fill');
        const propSpriteDiv = document.querySelector('.prop-sprite');
        const deleteElementButton = document.getElementById('delete-element-button');
        const generateCodeButton = document.getElementById('generate-code-button');
        const generatedCodePre = document.getElementById('generated-code');
        const showGridCheckbox = document.getElementById('show-grid');
        const snapGridCheckbox = document.getElementById('snap-grid');
        const elementListDiv = document.getElementById('element-list');
        const moveUpButton = document.getElementById('move-up-button');
        const moveDownButton = document.getElementById('move-down-button');

        // Animation Controls
        const animPanel = document.querySelector('.animation-panel');
        const noAnimSelectedMsg = document.getElementById('no-anim-element-selected');
        const selectedAnimControls = document.getElementById('selected-anim-controls');
        const animEndXInput = document.getElementById('anim-end-x');
        const animEndYInput = document.getElementById('anim-end-y');
        const animStepsInput = document.getElementById('anim-steps');
        const addAnimationButton = document.getElementById('add-animation-button');
        const removeAnimationButton = document.getElementById('remove-animation-button');
        const playAnimationButton = document.getElementById('play-animation-button');
        const stopAnimationButton = document.getElementById('stop-animation-button');


        // Sprite Editor Modal
        const spriteEditorModal = document.getElementById('spriteEditorModal');
        const closeModalSpan = document.querySelector('.modal .close');
        const spriteEditorGridDiv = document.getElementById('sprite-editor-grid');
        const spriteEditorWidthInput = document.getElementById('sprite-editor-width');
        const spriteEditorHeightInput = document.getElementById('sprite-editor-height');
        const resizeSpriteGridButton = document.getElementById('resize-sprite-grid');
        const newSpriteButton = document.getElementById('new-sprite-button');
        const saveSpriteButton = document.getElementById('save-sprite-button');
        const spriteLibrarySelect = document.getElementById('sprite-library-select');
        const loadSpriteButton = document.getElementById('load-sprite-button');
        const currentSpriteNameSpan = document.getElementById('current-sprite-name');
        const spriteNameInput = document.getElementById('sprite-name');
        const editSpriteButton = document.getElementById('edit-sprite-button');


        // --- State Variables ---
        let elements = []; // Array to store all drawn elements
        let spriteLibrary = {}; // Object to store named sprite data
        let selectedTool = 'select';
        let selectedElement = null;
        let dragInfo = null; // { element: ..., offsetX: ..., offsetY: ..., startX: ..., startY: ..., type: 'move' | 'resize' }
        let drawingShape = null; // { type: ..., startX: ..., startY: ..., currentX: ..., currentY: ... }
        let animationFrameId = null; // For animation preview

        // --- Grid/Snap State ---
        let showGrid = false;
        let snapGrid = false;

        // --- Sprite Editor State ---
        let currentSpriteData = null; // 2D array [y][x] of 0 or 1
        let currentSpriteName = 'new_sprite';


        // --- Drawing Functions ---
        function drawPixel(x, y, color) {
            // Clamp coordinates to display boundaries
            x = Math.max(0, Math.min(x, DISPLAY_WIDTH - 1));
            y = Math.max(0, Math.min(y, DISPLAY_HEIGHT - 1));
            ctx.fillStyle = color === 1 ? 'white' : 'black'; // SSD1306 "on" pixel is typically bright (white on black display)
            ctx.fillRect(x, y, 1, 1);
        }

        function drawLine(x0, y0, x1, y1, color) {
            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }

        function drawRect(x, y, w, h, color, fill = false) {
             // Clamp coordinates and size
            x = Math.max(0, x);
            y = Math.max(0, y);
            w = Math.min(w, DISPLAY_WIDTH - x);
            h = Math.min(h, DISPLAY_HEIGHT - y);

            if (w <= 0 || h <= 0) return;

            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.fillStyle = color === 1 ? 'white' : 'black';

            if (fill) {
                ctx.fillRect(x, y, w, h);
            } else {
                ctx.strokeRect(x, y, w, h);
            }
        }

        function drawCircle(cx, cy, r, color, fill = false) {
            // Clamp center and radius - simple clamp might clip.
            // For simplicity, just draw if center is within bounds. Clipping is more complex.
             if (cx < -r || cx > DISPLAY_WIDTH + r || cy < -r || cy > DISPLAY_HEIGHT + r) return;

            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.fillStyle = color === 1 ? 'white' : 'black';

            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);

            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

         function drawText(text, x, y, color) {
            // Text positioning is tricky on pixel displays. (x,y) is often top-left or baseline.
            // MicroPython framebuf uses (x,y) as top-left of the text bounding box. We'll simulate that.
             if (x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return; // Simple clipping

            ctx.fillStyle = color === 1 ? 'white' : 'black';
            // Use a simple monospace font matching typical display fonts
            ctx.font = '8px monospace'; // Assume 8px height for typical fonts

            // Ensure text stays within bounds horizontally
             let clippedText = text;
             let textMetrics = ctx.measureText(clippedText);
             while(x + textMetrics.width > DISPLAY_WIDTH && clippedText.length > 0) {
                 clippedText = clippedText.slice(0, -1);
                 textMetrics = ctx.measureText(clippedText);
             }
             if (clippedText.length === 0) return; // Text is too long to fit

            // Vertical position: MicroPython text often draws from the top-left of the character box.
            // Canvas drawText y is typically the baseline. We need to adjust.
            // A common font height is 8px. Let's assume that and adjust.
            const fontHeight = 8;
            const adjustedY = y + fontHeight; // Draw baseline at y + fontHeight

            // Only draw if at least part of the text is within vertical bounds
             if (adjustedY >= 0 && y < DISPLAY_HEIGHT) {
                ctx.fillText(clippedText, x, adjustedY);
             }
        }

        function drawSprite(x, y, spriteData, color) {
            if (!spriteData || spriteData.length === 0) return;

            const spriteHeight = spriteData.length;
            const spriteWidth = spriteData[0].length;

             // Clamp sprite position - simple clipping
             x = Math.max(0, x);
             y = Math.max(0, y);

            for (let j = 0; j < spriteHeight; j++) {
                for (let i = 0; i < spriteWidth; i++) {
                    if (spriteData[j][i] === 1) {
                        // Draw pixel only if it's 'on' and within display bounds
                         if (x + i < DISPLAY_WIDTH && y + j < DISPLAY_HEIGHT) {
                             drawPixel(x + i, y + j, color);
                         }
                    }
                }
            }
        }


        function drawGrid() {
            if (!showGrid) return;

            ctx.strokeStyle = '#111'; // Dark grey/black for grid lines on black background
            ctx.lineWidth = 0.5;

            // Vertical lines
            for (let x = 0; x < DISPLAY_WIDTH; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, DISPLAY_HEIGHT);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < DISPLAY_HEIGHT; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(DISPLAY_WIDTH, y);
                ctx.stroke();
            }
             ctx.lineWidth = 1; // Reset line width
        }

         function drawBoundingBox(element) {
             ctx.strokeStyle = 'red'; // Highlight color
             ctx.lineWidth = 1;
             ctx.setLineDash([2, 2]); // Dashed line

             let x, y, w, h;
             const padding = 1; // Small padding around the element

             switch (element.type) {
                 case 'pixel':
                     x = element.x - padding;
                     y = element.y - padding;
                     w = 1 + 2 * padding;
                     h = 1 + 2 * padding;
                     break;
                 case 'line':
                     // Bounding box of a line is min/max x,y
                     x = Math.min(element.x1, element.x2) - padding;
                     y = Math.min(element.y1, element.y2) - padding;
                     w = Math.abs(element.x1 - element.x2) + 1 + 2 * padding;
                     h = Math.abs(element.y1 - element.y2) + 1 + 2 * padding;
                     break;
                 case 'rect':
                 case 'filled-rect':
                     x = element.x - padding;
                     y = element.y - padding;
                     w = element.width + 2 * padding;
                     h = element.height + 2 * padding;
                     break;
                 case 'circle':
                 case 'filled-circle':
                      // Bounding box of a circle
                     x = element.cx - element.r - padding;
                     y = element.cy - element.r - padding;
                     w = element.r * 2 + 2 * padding;
                     h = element.r * 2 + 2 * padding;
                     break;
                 case 'text':
                      // Simple bounding box for text based on estimated font size
                     const textWidth = element.text.length * 8; // Estimate width assuming 8px wide chars
                     const textHeight = 8; // Estimate height
                     x = element.x - padding;
                     y = element.y - padding;
                     w = textWidth + 2 * padding;
                     h = textHeight + 2 * padding;
                     break;
                 case 'sprite':
                     const sprite = spriteLibrary[element.spriteDataRef];
                     if (!sprite) return;
                     x = element.x - padding;
                     y = element.y - padding;
                     w = sprite.width + 2 * padding;
                     h = sprite.height + 2 * padding;
                     break;
                 default:
                     return; // Don't draw box for unknown types
             }

             // Adjust clamped box to canvas bounds
             x = Math.max(0, x);
             y = Math.max(0, y);
             w = Math.min(w, DISPLAY_WIDTH - x);
             h = Math.min(h, DISPLAY_HEIGHT - y);


             ctx.strokeRect(x, y, w, h);

             ctx.setLineDash([]); // Reset line dash
             ctx.lineWidth = 1; // Reset line width
         }


        function draw() {
            ctx.clearRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT); // Fill background

            if (showGrid) {
                drawGrid();
            }

            elements.forEach(el => {
                // Check if element has animation data and update position if animation is playing (JS preview)
                if (el.animation && el.animation.progress !== undefined) {
                     const currentStep = el.animation.progress;
                     const totalSteps = el.animation.steps;
                     const startX = el.animation.startX;
                     const startY = el.animation.startY;
                     const endX = el.animation.endX;
                     const endY = el.animation.endY;

                     // Linear interpolation
                     el._currentRenderX = startX + (endX - startX) * (currentStep / totalSteps);
                     el._currentRenderY = startY + (endY - startY) * (currentStep / totalSteps);
                } else {
                    // Use stored x, y if no animation is active
                    el._currentRenderX = el.x;
                    el._currentRenderY = el.y;
                }


                // Draw element based on type
                switch (el.type) {
                    case 'pixel':
                         drawPixel(el._currentRenderX, el._currentRenderY, el.color);
                        break;
                    case 'line':
                         // For line, animation moves both points
                         const lineStartX = el.animation ? el.animation.startX : el.x1;
                         const lineStartY = el.animation ? el.animation.startY : el.y1;
                         const lineEndX = el.animation ? el.animation.endX : el.x2;
                         const lineEndY = el.animation ? el.animation.endY : el.y2;

                         let currentLineX1 = el._currentRenderX;
                         let currentLineY1 = el._currentRenderY;
                         let currentLineX2 = lineStartX + (lineEndX - lineStartX) * ((el.animation?.progress || 0) / (el.animation?.steps || 1));
                         let currentLineY2 = lineStartY + (lineEndY - lineStartY) * ((el.animation?.progress || 0) / (el.animation?.steps || 1));

                         // The _currentRenderX/Y tracks the movement of the "origin" point (x,y for rect, cx,cy for circle, x for text/sprite).
                         // For a line, we need to shift both start and end points by the delta movement of the 'origin'.
                         // Let's define the line origin as (x1, y1) for animation tracking.
                         const deltaX = (el._currentRenderX || el.x1) - el.x1;
                         const deltaY = (el._currentRenderY || el.y1) - el.y1;
                         drawLine(el.x1 + deltaX, el.y1 + deltaY, el.x2 + deltaX, el.y2 + deltaY, el.color);

                        break;
                    case 'rect':
                    case 'filled-rect':
                         drawRect(el._currentRenderX, el._currentRenderY, el.width, el.height, el.color, el.fill);
                        break;
                    case 'circle':
                    case 'filled-circle':
                         drawCircle(el._currentRenderX, el._currentRenderY, el.radius, el.color, el.fill);
                        break;
                    case 'text':
                         drawText(el.text, el._currentRenderX, el._currentRenderY, el.color);
                        break;
                    case 'sprite':
                        const spriteData = spriteLibrary[el.spriteDataRef];
                         if (spriteData) {
                            drawSprite(el._currentRenderX, el._currentRenderY, spriteData.data, el.color);
                         } else {
                             console.error(`Sprite data not found for reference: ${el.spriteDataRef}`);
                         }
                        break;
                }
            });

             // Draw bounding box for the selected element AFTER drawing all elements
             if (selectedElement) {
                 drawBoundingBox(selectedElement);
             }
        }

        // --- Helper Functions ---

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (event.clientX - rect.left) * scaleX;
            let y = (event.clientY - rect.top) * scaleY;

             if (snapGrid && (selectedTool === 'select' || drawingShape)) { // Apply snap only when selecting/moving or drawing
                 x = Math.round(x / GRID_SIZE) * GRID_SIZE;
                 y = Math.round(y / GRID_SIZE) * GRID_SIZE;
             }

            // Clamp to canvas boundaries
            x = Math.max(0, Math.min(x, DISPLAY_WIDTH - (selectedTool === 'pixel' || selectedTool === 'eraser' ? 1 : 0))); // Clamp pixel exactly
            y = Math.max(0, Math.min(y, DISPLAY_HEIGHT - (selectedTool === 'pixel' || selectedTool === 'eraser' ? 1 : 0))); // Clamp pixel exactly

            return { x: Math.round(x), y: Math.round(y) };
        }

         function updateMouseCoordinates(event) {
            const pos = getMousePos(event);
            mouseCoordsDiv.textContent = `(${pos.x}, ${pos.y})`;
        }

         function selectTool(tool) {
            selectedTool = tool;
            toolButtons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tool-${tool}`).classList.add('active');
            // Reset drawing state when tool changes
             drawingShape = null;
            // Deselect element unless the new tool is 'select' and an element is already selected
             if (tool !== 'select' || !selectedElement) {
                 selectElement(null);
             }
         }

         function updatePropertiesPanel() {
             if (selectedElement) {
                 noElementSelectedMsg.style.display = 'none';
                 propertiesPanel.style.display = 'block';

                 propTypeSpan.textContent = selectedElement.type;
                 propXInput.value = selectedElement.x;
                 propYInput.value = selectedElement.y;

                 // Hide/show specific properties based on element type
                 propTextDiv.style.display = (selectedElement.type === 'text') ? 'block' : 'none';
                 propSizeDivs.forEach(div => div.style.display = (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect' || selectedElement.type === 'sprite') ? 'block' : 'none');
                 propRadiusDiv.style.display = (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') ? 'block' : 'none';
                 propColorDiv.style.display = (selectedElement.type !== 'sprite') ? 'block' : 'none'; // Sprites use the sprite element's color
                 propFillDiv.style.display = (selectedElement.type === 'rect' || selectedElement.type === 'circle') ? 'block' : 'none'; // Only rect/circle have fill option

                 // Sprite specific property
                 propSpriteDiv.style.display = (selectedElement.type === 'sprite') ? 'block' : 'none';
                 if (selectedElement.type === 'sprite') {
                     // currentSpriteName = selectedElement.spriteDataRef; // Load sprite name into editor state? No, just reference.
                     // Need a way to edit the referenced sprite data... Maybe open the editor with the referenced sprite loaded.
                 }


                 // Update input values
                 if (selectedElement.type === 'text') propTextContentInput.value = selectedElement.text;
                 if (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect' || selectedElement.type === 'sprite') {
                      if (selectedElement.type === 'sprite') {
                          const sprite = spriteLibrary[selectedElement.spriteDataRef];
                           if(sprite) {
                                propWidthInput.value = sprite.width; // Display sprite dimensions
                                propHeightInput.value = sprite.height;
                                propWidthInput.disabled = true; // Cannot resize sprite via this panel
                                propHeightInput.disabled = true;
                           }
                      } else {
                        propWidthInput.value = selectedElement.width;
                        propHeightInput.value = selectedElement.height;
                         propWidthInput.disabled = false;
                         propHeightInput.disabled = false;
                      }
                 }
                 if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') propRadiusInput.value = selectedElement.radius;
                 if (selectedElement.type !== 'sprite') propColorSelect.value = selectedElement.color;
                 if (selectedElement.type === 'rect' || selectedElement.type === 'circle') propFillCheckbox.checked = selectedElement.fill;

                 // Update animation panel
                 updateAnimationPanel();

             } else {
                 noElementSelectedMsg.style.display = 'block';
                 propertiesPanel.style.display = 'none';
                 updateAnimationPanel(); // Hide animation controls too
             }
         }

         function updateAnimationPanel() {
             if (selectedElement) {
                 noAnimSelectedMsg.style.display = 'none';
                 selectedAnimControls.style.display = 'block';

                 // Show animation data if exists, otherwise show default values
                 if (selectedElement.animation) {
                     animEndXInput.value = selectedElement.animation.endX;
                     animEndYInput.value = selectedElement.animation.endY;
                     animStepsInput.value = selectedElement.animation.steps;
                     addAnimationButton.style.display = 'none';
                     removeAnimationButton.style.display = 'inline-block';
                 } else {
                     // Default end position to current + offset
                     animEndXInput.value = selectedElement.x + 10;
                     animEndYInput.value = selectedElement.y;
                     animStepsInput.value = 50;
                      addAnimationButton.style.display = 'inline-block';
                     removeAnimationButton.style.display = 'none';
                 }

             } else {
                 noAnimSelectedMsg.style.display = 'block';
                 selectedAnimControls.style.display = 'none';
             }
             // Animation preview controls are always visible if controls are visible,
             // but play/stop only work if animation data is set.
             playAnimationButton.disabled = !selectedElement || !selectedElement.animation;
             stopAnimationButton.disabled = animationFrameId === null; // Stop only active when playing
         }


         function updateElementList() {
             elementListDiv.innerHTML = '';
             elements.forEach((el, index) => {
                 const item = document.createElement('div');
                 item.classList.add('element-list-item');
                 if (el === selectedElement) {
                     item.classList.add('selected');
                 }
                 let label = `${el.type}`;
                 if (el.type === 'text') label += ` ("${el.text.substring(0, 10)}...")`;
                 if (el.type === 'sprite' && spriteLibrary[el.spriteDataRef]) label += ` (${el.spriteDataRef})`;
                 label += ` @ (${el.x},${el.y})`;
                 item.textContent = `${index}: ${label}`;
                 item.dataset.index = index;
                 item.addEventListener('click', () => {
                     selectElement(el);
                 });
                 elementListDiv.appendChild(item);
             });
             // Disable move buttons if no element selected or at list boundary
             moveUpButton.disabled = !selectedElement || elements.indexOf(selectedElement) === 0;
             moveDownButton.disabled = !selectedElement || elements.indexOf(selectedElement) === elements.length - 1;
         }

         function selectElement(element) {
             if (selectedElement === element) return; // Avoid re-selecting the same element

             // Stop any ongoing animation when selecting a new element
             stopAnimationPreview();

             selectedElement = element;
             updatePropertiesPanel();
             updateElementList();
             draw(); // Redraw to show/hide bounding box
         }


         function isPointInElement(x, y, element) {
            // Simple hit-testing based on bounding boxes
            switch (element.type) {
                case 'pixel':
                    return x === element.x && y === element.y;
                case 'line':
                    // More complex: check distance to line segment. For simplicity, check bounding box.
                     let minX = Math.min(element.x1, element.x2);
                     let maxX = Math.max(element.x1, element.x2);
                     let minY = Math.min(element.y1, element.y2);
                     let maxY = Math.max(element.y1, element.y2);
                     // Add a small tolerance for easier clicking
                     const tolerance = 2;
                     return x >= minX - tolerance && x <= maxX + tolerance && y >= minY - tolerance && y <= maxY + tolerance;
                case 'rect':
                case 'filled-rect':
                     return x >= element.x && x < element.x + element.width && y >= element.y && y < element.y + element.height;
                case 'circle':
                case 'filled-circle':
                     // Check if point is within radius of center
                     const dx = x - element.cx;
                     const dy = y - element.cy;
                     return dx * dx + dy * dy <= element.radius * element.radius;
                 case 'text':
                     // Simple bounding box for text
                     const textWidth = element.text.length * 8; // Estimate
                     const textHeight = 8; // Estimate
                     return x >= element.x && x < element.x + textWidth && y >= element.y && y < element.y + textHeight;
                 case 'sprite':
                     const sprite = spriteLibrary[element.spriteDataRef];
                     if (!sprite) return false;
                     return x >= element.x && x < element.x + sprite.width && y >= element.y && y < element.y + sprite.height;
                default:
                    return false;
            }
         }

        function snapToGrid(x, y) {
            if (!snapGrid) return { x, y };
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }


         // --- Event Handlers ---

         canvas.addEventListener('mousemove', (event) => {
             updateMouseCoordinates(event);
             const pos = getMousePos(event);

             // If drawing a shape, update its dimensions and redraw
             if (drawingShape) {
                 drawingShape.currentX = pos.x;
                 drawingShape.currentY = pos.y;
                 draw(); // Redraw with the current drawing shape
             } else if (dragInfo) {
                 // Moving an element
                 let newX = pos.x - dragInfo.offsetX;
                 let newY = pos.y - dragInfo.offsetY;

                 // Apply snapping if enabled
                 if (snapGrid) {
                      const snappedPos = snapToGrid(newX, newY);
                      newX = snappedPos.x;
                      newY = snappedPos.y;
                 }

                 // Update element's position. For lines, move both points.
                 if (dragInfo.element.type === 'line') {
                     const dx = newX - dragInfo.element.x1;
                     const dy = newY - dragInfo.element.y1;
                     dragInfo.element.x1 = newX;
                     dragInfo.element.y1 = newY;
                     dragInfo.element.x2 += dx;
                     dragInfo.element.y2 += dy;
                 } else {
                     dragInfo.element.x = newX;
                     dragInfo.element.y = newY;
                     // For circle, cx/cy are the center, x/y are top-left for consistency in storage
                     if (dragInfo.element.type === 'circle' || dragInfo.element.type === 'filled-circle') {
                          dragInfo.element.cx = dragInfo.element.x + dragInfo.element.radius;
                          dragInfo.element.cy = dragInfo.element.y + dragInfo.element.radius;
                     }
                 }


                 // Update properties panel if the dragged element is the selected one
                 if (dragInfo.element === selectedElement) {
                     updatePropertiesPanel();
                 }

                 draw(); // Redraw to show the element moving
             }
         });

         canvas.addEventListener('mousedown', (event) => {
             const pos = getMousePos(event);

             if (selectedTool === 'select') {
                 // Check if clicking on an existing element (iterate in reverse order for layers)
                 let clickedElement = null;
                 for (let i = elements.length - 1; i >= 0; i--) {
                     if (isPointInElement(pos.x, pos.y, elements[i])) {
                         clickedElement = elements[i];
                         break;
                     }
                 }

                 if (clickedElement) {
                     selectElement(clickedElement);
                     // Start drag operation
                     dragInfo = {
                         element: clickedElement,
                         // Store offset from top-left for simple drag
                         offsetX: pos.x - clickedElement.x,
                         offsetY: pos.y - clickedElement.y,
                         startX: clickedElement.x, // Store initial position
                         startY: clickedElement.y,
                         type: 'move' // Could add 'resize' later
                     };
                      // For line, use x1, y1 as the origin for drag calculation
                      if (clickedElement.type === 'line') {
                           dragInfo.offsetX = pos.x - clickedElement.x1;
                           dragInfo.offsetY = pos.y - clickedElement.y1;
                           dragInfo.startX = clickedElement.x1;
                           dragInfo.startY = clickedElement.y1;
                      } else if (clickedElement.type === 'circle' || clickedElement.type === 'filled-circle') {
                           // Use the stored x,y (top-left of bounding box) for drag
                           dragInfo.offsetX = pos.x - clickedElement.x;
                           dragInfo.offsetY = pos.y - clickedElement.y;
                           dragInfo.startX = clickedElement.x;
                           dragInfo.startY = clickedElement.y;
                      }

                 } else {
                     // Clicked outside elements, deselect
                     selectElement(null);
                     dragInfo = null; // No drag started
                 }
             } else if (selectedTool === 'pixel') {
                 elements.push({ type: 'pixel', x: pos.x, y: pos.y, color: 1 });
                 draw();
                 updateElementList();
             } else if (selectedTool === 'eraser') {
                 // Remove pixel if one exists at this location
                 const initialLength = elements.length;
                 elements = elements.filter(el =>
                     !(el.type === 'pixel' && el.x === pos.x && el.y === pos.y)
                 );
                  if (elements.length < initialLength) {
                     draw();
                     updateElementList();
                     // If the deleted element was selected, deselect it
                     if (selectedElement && selectedElement.type === 'pixel' && selectedElement.x === pos.x && selectedElement.y === pos.y) {
                         selectElement(null);
                     }
                 }
             } else if (selectedTool === 'sprite' && currentSpriteData && currentSpriteName && spriteLibrary[currentSpriteName]) {
                  // Place the currently saved sprite
                  const sprite = spriteLibrary[currentSpriteName];
                  elements.push({ type: 'sprite', x: pos.x, y: pos.y, spriteDataRef: currentSpriteName, color: 1 }); // Sprites use a reference and a color tint
                  draw();
                  updateElementList();
             }
             else {
                 // Start drawing a shape
                 drawingShape = {
                     type: selectedTool, // e.g., 'line', 'rect', 'circle', 'filled-rect', 'filled-circle', 'text' (temp)
                     startX: pos.x,
                     startY: pos.y,
                     currentX: pos.x,
                     currentY: pos.y,
                     color: parseInt(propColorSelect.value), // Get color from controls
                     fill: selectedTool.startsWith('filled-')
                 };

                 // Handle Text tool start
                 if (selectedTool === 'text') {
                      // For text, mousedown just sets the position. The element is added on mouseup or a different action.
                      // Let's simplify: mousedown places text immediately.
                     const text = propTextContentInput.value || "Hello";
                     if (text) {
                         elements.push({ type: 'text', x: pos.x, y: pos.y, text: text, color: parseInt(propColorSelect.value) });
                         draw();
                         updateElementList();
                     }
                     drawingShape = null; // Text is placed instantly, not drawn with drag
                 }
             }
         });

         canvas.addEventListener('mouseup', (event) => {
             const pos = getMousePos(event);

             if (dragInfo) {
                 // End drag operation
                 dragInfo = null;
             } else if (drawingShape && drawingShape.type !== 'text') {
                 // End drawing a shape and add it to elements
                 const startX = drawingShape.startX;
                 const startY = drawingShape.startY;
                 const endX = pos.x; // Use final mouse position
                 const endY = pos.y;
                 const color = drawingShape.color;
                 const fill = drawingShape.fill;

                 let newElement = null;

                 switch (drawingShape.type) {
                     case 'line':
                         newElement = { type: 'line', x1: startX, y1: startY, x2: endX, y2: endY, color: color };
                         break;
                     case 'rect':
                     case 'filled-rect':
                         // Ensure width and height are positive, adjust x/y if dragging left/up
                         const x = Math.min(startX, endX);
                         const y = Math.min(startY, endY);
                         const width = Math.abs(startX - endX) + 1; // +1 to include the end pixel
                         const height = Math.abs(startY - endY) + 1; // +1 to include the end pixel
                         newElement = { type: 'rect', x: x, y: y, width: width, height: height, color: color, fill: fill };
                         break;
                      case 'circle':
                      case 'filled-circle':
                          // Define circle by center and radius. Let's treat start as center and end as a point on circumference.
                          // Or, treat start as one corner of bounding box, end as opposite?
                          // Let's simplify: Start = Center, End determines Radius.
                          const dx = endX - startX;
                          const dy = endY - startY;
                          const radius = Math.round(Math.sqrt(dx * dx + dy * dy));
                           // Store center (cx, cy) and radius (r). Also store top-left (x,y) for consistent property panel/drag
                           newElement = {
                                type: 'circle',
                                cx: startX,
                                cy: startY,
                                radius: radius,
                                x: startX - radius, // Top-left of bounding box
                                y: startY - radius, // Top-left of bounding box
                                color: color,
                                fill: fill
                           };
                          break;
                 }

                 if (newElement) {
                     elements.push(newElement);
                     selectElement(newElement); // Select the newly created element
                     updateElementList();
                 }

                 drawingShape = null; // Stop drawing mode
                 draw(); // Redraw with the finished shape
             }
         });

         canvas.addEventListener('mouseout', (event) => {
             mouseCoordsDiv.textContent = `(0, 0)`; // Reset coords when mouse leaves
         });

         // --- Property Panel Event Listeners ---
         propXInput.addEventListener('change', (event) => {
             if (selectedElement) {
                 const newX = parseInt(event.target.value);
                  // For circles, changing X needs to update cx and the stored x
                  if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') {
                      const dx = newX - selectedElement.x; // Change in x
                      selectedElement.x = newX;
                      selectedElement.cx += dx;
                  } else if (selectedElement.type === 'line') {
                      // For lines, changing X needs to move both points
                       const dx = newX - selectedElement.x1;
                       selectedElement.x1 = newX;
                       selectedElement.x2 += dx;
                  }
                 else {
                    selectedElement.x = newX;
                 }
                 draw();
                 updateElementList(); // Update position in list label
             }
         });

         propYInput.addEventListener('change', (event) => {
            if (selectedElement) {
                 const newY = parseInt(event.target.value);
                 // For circles, changing Y needs to update cy and the stored y
                 if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') {
                     const dy = newY - selectedElement.y; // Change in y
                     selectedElement.y = newY;
                     selectedElement.cy += dy;
                 } else if (selectedElement.type === 'line') {
                       // For lines, changing Y needs to move both points
                       const dy = newY - selectedElement.y1;
                       selectedElement.y1 = newY;
                       selectedElement.y2 += dy;
                 }
                 else {
                    selectedElement.y = newY;
                 }

                 draw();
                 updateElementList(); // Update position in list label
             }
         });

         propTextContentInput.addEventListener('change', (event) => {
             if (selectedElement && selectedElement.type === 'text') {
                 selectedElement.text = event.target.value;
                 draw();
             }
         });

         propWidthInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect')) {
                 selectedElement.width = parseInt(event.target.value);
                 draw();
             }
         });

         propHeightInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect')) {
                 selectedElement.height = parseInt(event.target.value);
                 draw();
             }
         });

         propRadiusInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle')) {
                 const newRadius = parseInt(event.target.value);
                 selectedElement.radius = newRadius;
                 // Update stored x,y (top-left) based on new radius
                 selectedElement.x = selectedElement.cx - newRadius;
                 selectedElement.y = selectedElement.cy - newRadius;
                 draw();
             }
         });

         propColorSelect.addEventListener('change', (event) => {
             if (selectedElement) {
                 selectedElement.color = parseInt(event.target.value);
                 draw();
             }
         });

         propFillCheckbox.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'rect' || selectedElement.type === 'circle')) {
                 selectedElement.fill = event.target.checked;
                 // Change type name in UI if needed (e.g., rect -> filled-rect)
                 if (selectedElement.type === 'rect' && selectedElement.fill) selectedElement.type = 'filled-rect';
                 if (selectedElement.type === 'filled-rect' && !selectedElement.fill) selectedElement.type = 'rect';
                 if (selectedElement.type === 'circle' && selectedElement.fill) selectedElement.type = 'filled-circle';
                 if (selectedElement.type === 'filled-circle' && !selectedElement.fill) selectedElement.type = 'circle';
                 updatePropertiesPanel(); // Update type name shown
                 draw();
             }
         });

         deleteElementButton.addEventListener('click', () => {
            if (selectedElement) {
                const index = elements.indexOf(selectedElement);
                if (index !== -1) {
                    elements.splice(index, 1);
                    selectElement(null); // Deselect
                    draw();
                    updateElementList();
                }
            }
         });

         // --- Toolbar Button Event Listeners ---
         toolButtons.forEach(button => {
             if (button.id.startsWith('tool-')) {
                 button.addEventListener('click', () => {
                     selectTool(button.id.replace('tool-', ''));
                 });
             }
         });

         // --- Grid/Snap Event Listeners ---
         showGridCheckbox.addEventListener('change', (event) => {
             showGrid = event.target.checked;
             draw();
         });
          snapGridCheckbox.addEventListener('change', (event) => {
             snapGrid = event.target.checked;
             // No redraw needed, snap applies during mouse events
         });


         // --- Layer Controls ---
         moveUpButton.addEventListener('click', () => {
             if (selectedElement) {
                 const index = elements.indexOf(selectedElement);
                 if (index > 0) {
                     // Swap elements
                     [elements[index], elements[index - 1]] = [elements[index - 1], elements[index]];
                     updateElementList();
                     draw(); // Redraw with new layer order
                 }
             }
         });

         moveDownButton.addEventListener('click', () => {
             if (selectedElement) {
                 const index = elements.indexOf(selectedElement);
                 if (index < elements.length - 1) {
                     // Swap elements
                     [elements[index], elements[index + 1]] = [elements[index + 1], elements[index]];
                     updateElementList();
                     draw(); // Redraw with new layer order
                 }
             }
         });


         // --- Animation Preview ---
         function playAnimationPreview() {
            if (!selectedElement || !selectedElement.animation) return;

            const anim = selectedElement.animation;
            anim.progress = 0; // Start at step 0
            anim.startTime = performance.now(); // Record start time
            anim.startX = selectedElement.x; // Store current pos as start for animation
            anim.startY = selectedElement.y;

            // Make a deep copy of the initial state of all elements for consistent preview
             const initialElementsState = JSON.parse(JSON.stringify(elements));

            function animate(currentTime) {
                if (!anim.startTime) anim.startTime = currentTime;

                const elapsedTime = currentTime - anim.startTime;
                 // Calculate which step we are at based on elapsed time and total steps (assume ~30-60fps)
                 // A simpler approach is to just increment step per frame
                 anim.progress++;


                if (anim.progress <= anim.steps) {
                    // Restore initial state, then update the selected element's position for this frame
                     elements = JSON.parse(JSON.stringify(initialElementsState)); // Start from the beginning state
                     const elementToAnimate = elements.find(el => el.id === selectedElement.id); // Find the animating element in the current frame's state copy

                     if (elementToAnimate) {
                         const currentStep = anim.progress;
                         const totalSteps = anim.steps;

                          // Update position based on progress
                         elementToAnimate.x = anim.startX + (anim.endX - anim.startX) * (currentStep / totalSteps);
                         elementToAnimate.y = anim.startY + (anim.endY - anim.startY) * (currentStep / totalSteps);

                          // Update element._currentRenderX/Y to the new position
                          elementToAnimate._currentRenderX = elementToAnimate.x;
                          elementToAnimate._currentRenderY = elementToAnimate.y;

                         // Update properties panel during animation? Probably too distracting.
                     } else {
                          console.error("Animating element not found in frame state copy!");
                          stopAnimationPreview();
                          return;
                     }


                    draw(); // Redraw the canvas for this frame

                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    // Animation finished
                    stopAnimationPreview();
                    // Optionally reset element position to end state or original start state
                     // Let's reset to the state *before* animation started for clarity in the editor
                    elements = JSON.parse(JSON.stringify(initialElementsState));
                     draw();
                }
            }

             playAnimationButton.disabled = true;
             stopAnimationButton.disabled = false;
            animationFrameId = requestAnimationFrame(animate);
         }

         function stopAnimationPreview() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                // Reset the animated element's position in the main elements array
                if (selectedElement && selectedElement.animation) {
                     // Restore the original position before animation started
                     selectedElement.x = selectedElement.animation.startX;
                     selectedElement.y = selectedElement.animation.startY;
                     delete selectedElement.animation.progress; // Remove progress state
                     delete selectedElement.animation.startTime;
                     delete selectedElement._currentRenderX; // Clear rendering position override
                     delete selectedElement._currentRenderY;
                     delete selectedElement.animation.startX; // Remove start pos stored for anim
                     delete selectedElement.animation.startY;
                }
                 draw(); // Redraw to show static state
                 playAnimationButton.disabled = !selectedElement || !selectedElement.animation;
                 stopAnimationButton.disabled = true;
            }
         }


         addAnimationButton.addEventListener('click', () => {
             if (selectedElement) {
                 selectedElement.animation = {
                     type: 'path', // Only supporting path for now
                     startX: selectedElement.x,
                     startY: selectedElement.y,
                     endX: parseInt(animEndXInput.value),
                     endY: parseInt(animEndYInput.value),
                     steps: parseInt(animStepsInput.value)
                 };
                 // Assign a unique ID to the element so we can find it in the copied state during animation
                 if (!selectedElement.id) {
                      selectedElement.id = Date.now() + Math.random();
                 }
                 updateAnimationPanel();
                 console.log(`Animation added to element ${selectedElement.type} at (${selectedElement.x},${selectedElement.y})`);
             }
         });

         removeAnimationButton.addEventListener('click', () => {
             if (selectedElement && selectedElement.animation) {
                 stopAnimationPreview(); // Stop if playing
                 delete selectedElement.animation;
                 //delete selectedElement.id; // Remove ID if no longer needed? Maybe keep ID for other purposes later.
                 updateAnimationPanel();
                 console.log('Animation removed.');
             }
         });

         playAnimationButton.addEventListener('click', playAnimationPreview);
         stopAnimationButton.addEventListener('click', stopAnimationPreview);


         // --- Sprite Editor Functions ---

         function generateSpriteGrid(width, height) {
            spriteEditorGridDiv.innerHTML = '';
            spriteEditorGridDiv.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            spriteEditorGridDiv.style.width = `${width * 16}px`; // Cell size + border
            spriteEditorGridDiv.style.height = `${height * 16}px`;

            currentSpriteData = [];
            for (let y = 0; y < height; y++) {
                currentSpriteData[y] = [];
                for (let x = 0; x < width; x++) {
                    currentSpriteData[y][x] = 0; // Initialize with 0 (off)
                    const pixelDiv = document.createElement('div');
                    pixelDiv.classList.add('pixel');
                    pixelDiv.dataset.x = x;
                    pixelDiv.dataset.y = y;
                    pixelDiv.addEventListener('click', toggleSpritePixel);
                    spriteEditorGridDiv.appendChild(pixelDiv);
                }
            }
         }

         function toggleSpritePixel(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);
            if (currentSpriteData && currentSpriteData[y] !== undefined && currentSpriteData[y][x] !== undefined) {
                currentSpriteData[y][x] = 1 - currentSpriteData[y][x]; // Toggle 0 to 1, 1 to 0
                event.target.classList.toggle('on', currentSpriteData[y][x] === 1);
            }
         }

         function loadSpriteIntoEditor(spriteData, width, height) {
             spriteEditorWidthInput.value = width;
             spriteEditorHeightInput.value = height;
             generateSpriteGrid(width, height); // Re-generate grid

             // Load pixel data
             for (let y = 0; y < height; y++) {
                 for (let x = 0; x < width; x++) {
                     if (spriteData[y] && spriteData[y][x] === 1) {
                         const pixelDiv = spriteEditorGridDiv.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                         if (pixelDiv) {
                             pixelDiv.classList.add('on');
                             currentSpriteData[y][x] = 1; // Update state data
                         }
                     }
                 }
             }
         }

         function updateSpriteLibrarySelect() {
             spriteLibrarySelect.innerHTML = '<option value="">-- Load Sprite --</option>';
             for (const name in spriteLibrary) {
                 const option = document.createElement('option');
                 option.value = name;
                 option.textContent = name;
                 spriteLibrarySelect.appendChild(option);
             }
         }

         // --- Sprite Editor Event Listeners ---
         editSpriteButton.addEventListener('click', () => {
             if (selectedElement && selectedElement.type === 'sprite' && spriteLibrary[selectedElement.spriteDataRef]) {
                 const sprite = spriteLibrary[selectedElement.spriteDataRef];
                 currentSpriteName = selectedElement.spriteDataRef;
                 spriteNameInput.value = currentSpriteName;
                 currentSpriteNameSpan.textContent = currentSpriteName;
                 loadSpriteIntoEditor(sprite.data, sprite.width, sprite.height);
             } else {
                 // If no sprite element selected or sprite data missing, start a new default sprite
                 currentSpriteName = 'new_sprite';
                 spriteNameInput.value = currentSpriteName;
                 currentSpriteNameSpan.textContent = currentSpriteName;
                 generateSpriteGrid(8, 8); // Default size
             }
             spriteEditorModal.style.display = 'block';
         });

         closeModalSpan.addEventListener('click', () => {
             spriteEditorModal.style.display = 'none';
         });

         window.addEventListener('click', (event) => {
             if (event.target === spriteEditorModal) {
                 spriteEditorModal.style.display = 'none';
             }
         });

         resizeSpriteGridButton.addEventListener('click', () => {
             const width = parseInt(spriteEditorWidthInput.value);
             const height = parseInt(spriteEditorHeightInput.value);
             if (width >= 1 && width <= 32 && height >= 1 && height <= 32) {
                  // Preserve existing pixels if grid shrinks/grows
                 const oldData = currentSpriteData;
                 const oldWidth = oldData ? oldData[0].length : 0;
                 const oldHeight = oldData ? oldData.length : 0;

                 generateSpriteGrid(width, height); // Creates new empty grid and updates currentSpriteData

                 // Copy old data to new grid
                 if (oldData) {
                      const copyWidth = Math.min(width, oldWidth);
                      const copyHeight = Math.min(height, oldHeight);
                      for(let y = 0; y < copyHeight; y++) {
                           for(let x = 0; x < copyWidth; x++) {
                                if (oldData[y] && oldData[y][x] === 1) {
                                    currentSpriteData[y][x] = 1;
                                     const pixelDiv = spriteEditorGridDiv.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                                     if(pixelDiv) pixelDiv.classList.add('on');
                                }
                           }
                      }
                 }

             } else {
                 alert('Sprite dimensions must be between 1 and 32.');
             }
         });

         newSpriteButton.addEventListener('click', () => {
             currentSpriteName = 'new_sprite_' + Date.now(); // Unique temp name
             spriteNameInput.value = currentSpriteName;
             currentSpriteNameSpan.textContent = currentSpriteName;
             generateSpriteGrid(8, 8); // Default size
         });

         saveSpriteButton.addEventListener('click', () => {
             const name = spriteNameInput.value.trim();
             const width = parseInt(spriteEditorWidthInput.value);
             const height = parseInt(spriteEditorHeightInput.value);

             if (!name) {
                 alert('Sprite name cannot be empty.');
                 return;
             }
             if (!currentSpriteData || width <= 0 || height <= 0) {
                 alert('Sprite data is empty.');
                 return;
             }

             // Store sprite data and dimensions
             spriteLibrary[name] = {
                 name: name,
                 width: width,
                 height: height,
                 data: JSON.parse(JSON.stringify(currentSpriteData)) // Store a copy
             };
             currentSpriteName = name; // Set current name to saved name
             currentSpriteNameSpan.textContent = name;
             updateSpriteLibrarySelect();
             alert(`Sprite "${name}" saved!`);

             // If the currently selected element is a sprite, update its reference if the name changed
             if (selectedElement && selectedElement.type === 'sprite' && selectedElement.spriteDataRef !== name) {
                  selectedElement.spriteDataRef = name;
                  updatePropertiesPanel(); // Update sprite name shown in properties
                  draw(); // Redraw to reflect potential size change if loaded sprite was different size
             }
         });

         loadSpriteButton.addEventListener('click', () => {
            const name = spriteLibrarySelect.value;
            if (name && spriteLibrary[name]) {
                const sprite = spriteLibrary[name];
                currentSpriteName = name;
                spriteNameInput.value = currentSpriteName;
                currentSpriteNameSpan.textContent = currentSpriteName;
                loadSpriteIntoEditor(sprite.data, sprite.width, sprite.height);
            } else {
                alert('Please select a sprite to load.');
            }
         });


         // --- Code Generation ---

         function generateMicroPythonCode() {
            let code = `# MicroPython Code Generated by OLED UI Editor\n`;
            code += `# This code is designed to work with an SSD1306 driver library compatible with framebuf.\n`;
            code += `# e.g., https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py\n\n`;

            code += `# IMPORTANT: You need to have the ssd1306.py library file on your Pico.\n`;
            code += `# Adjust the import and display setup below based on your connections (I2C or SPI) and pins.\n`;
            code += `# Example for I2C:\n`;
            code += `import machine\n`;
            code += `import ssd1306\n`;
            code += `import time\n\n`;
            code += `# Example I2C setup (adjust pins and address as needed):\n`;
            code += `i2c = machine.I2C(0, scl=machine.Pin(1), sda=machine.Pin(0))\n`;
            code += `display = ssd1306.SSD1306_I2C(${DISPLAY_WIDTH}, ${DISPLAY_HEIGHT}, i2c)\n\n`;
            code += `# Example for SPI (adjust pins and baudrate as needed):\n`;
            code += `# import machine\n`;
            code += `# import ssd1306\n`;
            code += `# import time\n\n`;
            code += `# spi = machine.SPI(0, baudrate=10000000, polarity=0, phase=0, sck=machine.Pin(2), mosi=machine.Pin(3))\n`;
            code += `# dc = machine.Pin(4, machine.Pin.OUT)\n`;
            code += `# res = machine.Pin(5, machine.Pin.OUT)\n`;
            code += `# cs = machine.Pin(6, machine.Pin.OUT)\n`;
            code += `# display = ssd1306.SSD1306_SPI(${DISPLAY_WIDTH}, ${DISPLAY_HEIGHT}, spi, dc, res, cs)\n\n`;


            // Generate Sprite Data
             code += `# --- Sprite Data ---\n`;
             for (const name in spriteLibrary) {
                 const sprite = spriteLibrary[name];
                 const flatData = [];
                 // Convert 2D array to byte array (assuming vertical bit packing as per framebuf)
                 // Each byte represents 8 vertical pixels in a column
                 for (let i = 0; i < sprite.width; i++) { // Iterate columns
                     for (let j = 0; j < sprite.height; j += 8) { // Iterate down in 8-pixel chunks
                         let byte = 0;
                         for (let k = 0; k < 8; k++) {
                             const pixelY = j + k;
                              if (pixelY < sprite.height) {
                                 if (sprite.data[pixelY] && sprite.data[pixelY][i] === 1) {
                                     byte |= (1 << k); // Set bit k if pixel is on
                                 }
                              }
                         }
                         flatData.push(byte);
                     }
                 }
                 code += `${name}_data = bytearray([${flatData.map(b => `0x${b.toString(16).padStart(2, '0')}`).join(', ')}]) # ${sprite.width}x${sprite.height}\n`;
             }
             code += `\n`;

            // Generate initial elements data structure
            code += `# --- Element Definitions (Initial State) ---\n`;
            code += `elements_data = [\n`;
            elements.forEach(el => {
                code += `    {\n`;
                code += `        "type": "${el.type}",\n`;
                // Store base position (x,y or x1,y1 or cx,cy)
                 if (el.type === 'line') {
                     code += `        "x1": ${el.x1}, "y1": ${el.y1}, "x2": ${el.x2}, "y2": ${el.y2},\n`;
                 } else if (el.type === 'circle' || el.type === 'filled-circle') {
                     code += `        "cx": ${el.cx}, "cy": ${el.cy}, "radius": ${el.radius},\n`;
                 }
                 else {
                    code += `        "x": ${el.x}, "y": ${el.y},\n`;
                 }


                // Add type-specific properties
                if (el.type === 'text') {
                    code += `        "text": "${el.text}",\n`;
                } else if (el.type === 'rect' || el.type === 'filled-rect') {
                    code += `        "width": ${el.width}, "height": ${el.height},\n`;
                } else if (el.type === 'sprite') {
                     const sprite = spriteLibrary[el.spriteDataRef];
                     if (sprite) {
                         code += `        "spriteDataRef": ${el.spriteDataRef}_data, # Reference to bytearray\n`;
                         code += `        "width": ${sprite.width}, "height": ${sprite.height}, # Sprite dimensions\n`;
                     } else {
                          code += `        # Error: Sprite data "${el.spriteDataRef}" not found!\n`;
                     }
                }
                 // Add common properties
                 if (el.type !== 'sprite') { // Sprites get color handled during blitting
                     code += `        "color": ${el.color},\n`;
                 } else {
                      // Add color for sprite, which will be the foreground color for blit
                       code += `        "color": ${el.color},\n`;
                 }

                if (el.type === 'rect' || el.type === 'circle') {
                    code += `        "fill": ${el.fill},\n`;
                }

                 // Add animation data (if any) for the user's reference
                 if (el.animation) {
                     code += `        # Animation Data (For User Reference) -\n`;
                     // Store start position explicitly in animation data for the Python code
                     let startX = el.type === 'line' ? el.x1 : (el.type === 'circle' || el.type === 'filled-circle' ? el.cx : el.x);
                     let startY = el.type === 'line' ? el.y1 : (el.type === 'circle' || el.type === 'filled-circle' ? el.cy : el.y);

                     code += `        "animation": {\n`;
                     code += `            "type": "${el.animation.type}", # e.g., 'path'\n`;
                     code += `            "startX": ${startX}, "startY": ${startY},\n`;
                     code += `            "endX": ${el.animation.endX}, "endY": ${el.animation.endY},\n`;
                     code += `            "steps": ${el.animation.steps}\n`;
                     code += `        },\n`;
                 }

                code += `    },\n`;
            });
            code += `]\n\n`;

            // Drawing function in Python
            code += `# --- Drawing Function ---\n`;
            code += `def draw_elements(display, elements):\n`;
            code += `    """Draws a list of element dictionaries onto the display buffer."""\n`;
            code += `    for el in elements:\n`;
            code += `        el_type = el["type"]\n`;
             code += `        color = el.get("color", 1) # Default color 1 if not specified\n`;
            code += `        fill = el.get("fill", False)\n\n`;
            code += `        if el_type == "pixel":\n`;
            code += `            display.pixel(el["x"], el["y"], color)\n`;
            code += `        elif el_type == "line":\n`;
            code += `            display.line(el["x1"], el["y1"], el["x2"], el["y2"], color)\n`;
            code += `        elif el_type in ["rect", "filled-rect"]:\n`;
            code += `            if fill:\n`;
            code += `                display.fill_rect(el["x"], el["y"], el["width"], el["height"], color)\n`;
            code += `            else:\n`;
            code += `                display.rect(el["x"], el["y"], el["width"], el["height"], color)\n`;
            code += `        elif el_type in ["circle", "filled-circle"]:\n`;
            code += `            if fill:\n`;
            code += `                # Note: SSD1306 library might not have fill_circle. This is a placeholder.\n`;
                // Use ellipse function for filled circle if fill_circle is not available? Need to check library.
                // The user-provided library HAS circle and fill. Let's use that.
            code += `                # display.fill_circle(el["cx"], el["cy"], el["radius"], color) # Placeholder if library had it\n`;
            code += `                # Using the circle function from the provided library for filled circles:\n`;
            code += `                # The provided library's circle method has a 'fill' parameter.\n`;
            code += `                display.circle(el["cx"], el["cy"], el["radius"], color, fill=True)\n`;
            code += `            else:\n`;
            code += `                display.circle(el["cx"], el["cy"], el["radius"], color, fill=False)\n`;
            code += `        elif el_type == "text":\n`;
            code += `            display.text(el["text"], el["x"], el["y"], color)\n`;
            code += `        elif el_type == "sprite":\n`;
             code += `            # Assumes your SSD1306 library has a blit method compatible with framebuf\n`;
             code += `            # Or you might need a custom sprite drawing function.\n`;
             code += `            # The provided library has blit which works with framebuf objects. Create a temporary framebuf.\n`;
             code += `            sprite_buf = framebuf.FrameBuffer(el["spriteDataRef"], el["width"], el["height"], framebuf.MONO_VLSB)\n`;
             code += `            display.blit(sprite_buf, el["x"], el["y"])\n`;
             code += `            # Note: Color tinting for blit might require manual pixel manipulation or a different blit method.\n`;
             code += `            # The simple blit copies pixels as is (1s are 'on', 0s are 'off').\n`;
             code += `            # If color is 0, you might want to blit the inverse or skip.\n`;
             code += `            if color == 0:\n`;
             code += `                # If color is off (0), effectively draw with the background color.\n`;
             code += `                # This might require blitting an inverse or using a different method.\n`;
             code += `                # For monochrome, drawing with color 0 on a black background means turning pixels OFF.\n`;
             code += `                # The default blit with MONO_VLSB assumes 1s turn pixels ON.\n`;
             code += `                # If you need to draw sprites that turn pixels OFF, a custom function is needed.\n`;
             code += `                # For simplicity, this generated code assumes color=1 means ON pixels from sprite data.\n`;
             code += `                pass # Current blit handles 1 (on) pixels. Ignore if color is 0.\n`;


            code += `\n`;


            // Main execution block with animation suggestion
            code += `# --- Main Execution ---\n`;
            code += `if __name__ == "__main__":\n`;
            code += `    print("Drawing initial state...")\n`;
            code += `    display.fill(0) # Clear the display buffer\n`;
            code += `    draw_elements(display, elements_data) # Draw all elements\n`;
            code += `    display.show() # Push the buffer to the display\n`;
            code += `    #time.sleep(2) # Display initial state for a few seconds\n\n`;

            code += `    # --- Animation Example (Modify as needed) ---\n`;
            code += `    # To animate elements, you would typically update their positions\n`;
            code += `    # in the 'elements_data' list within a loop.\n`;
            code += `    # For elements with animation data defined:\n`;
            code += `    # animated_element = next((el for el in elements_data if "animation" in el), None)\n`; # Find first animated element
            code += `\n`;
            code += `    # if animated_element:\n`;
            code += `    #     anim = animated_element["animation"]\n`;
            code += `    #     print(f"Starting animation for {animated_element['type']}...")\n`;
            code += `    #     start_x = anim["startX"]\n`;
            code += `    #     start_y = anim["startY"]\n`;
            code += `    #     end_x = anim["endX"]\n`;
            code += `    #     end_y = anim["endY"]\n`;
            code += `    #     steps = anim["steps"]\n`;
            code += `\n`;
            code += `    #     for step in range(steps + 1):\n`;
            code += `    #         # Calculate current position using linear interpolation\n`;
            code += `    #         current_x = int(start_x + (end_x - start_x) * (step / steps))\n`;
            code += `    #         current_y = int(start_y + (end_y - start_y) * (step / steps))\n`;
            code += `\n`;
            code += `    #         # Update the element's position in the list\n`;
            code += `    #         # Note: If animating a line or circle, you might need to update x1/y1/x2/y2 or cx/cy\n`;
            code += `    #         if animated_element["type"] == "line":\n`;
            code += `    #             # Move both points relative to the start point's movement\n`;
            code += `    #             dx = current_x - start_x\n`;
            code += `    #             dy = current_y - start_y\n`;
            code += `    #             animated_element["x1"] = start_x + dx # The 'start_x' in anim is the line's initial x1\n`;
            code += `    #             animated_element["y1"] = start_y + dy # The 'start_y' in anim is the line's initial y1\n`;
            code += `    #             # Need original x2, y2 to calculate delta movement correctly\n`;
            code += `    #             # This gets complicated quickly with different element origins and animation types.\n`;
            code += `    #             # Consider storing original x2, y2 in animation data or using a more robust animation system.\n`;
            code += `    #             pass # Simplified: User implements complex element-specific updates\n`;
            code += `    #         elif animated_element["type"] in ["circle", "filled-circle"]:\n`;
            code += `    #              animated_element["cx"] = current_x\n`;
            code += `    #              animated_element["cy"] = current_y\n`;
            code += `    #              # Also update x,y for bounding box if needed\n`;
            code += `    #              animated_element["x"] = current_x - animated_element["radius"]\n`;
            code += `    #              animated_element["y"] = current_y - animated_element["radius"]\n`;
            code += `    #         else:\n`;
            code += `    #             animated_element["x"] = current_x\n`;
            code += `    #             animated_element["y"] = current_y\n`;
            code += `\n`;
            code += `    #         display.fill(0) # Clear the previous frame\n`;
            code += `    #         draw_elements(display, elements_data) # Draw elements at their new positions\n`;
            code += `    #         display.show() # Update the display\n`;
            code += `    #         #time.sleep(0.05) # Add a small delay (e.g., ~20 FPS)\n`;
            code += `\n`;
            code += `    print("Done.")\n`;


            generatedCodePre.textContent = code;
         }


         generateCodeButton.addEventListener('click', generateMicroPythonCode);


        // --- Initialization ---
        function initialize() {
            // Scale canvas for better visibility in browser
            canvas.style.width = `${DISPLAY_WIDTH * SCALE}px`;
            canvas.style.height = `${DISPLAY_HEIGHT * SCALE}px`;

            // Load some predefined sprites
            spriteLibrary = {
                 "smiley": {
                     name: "smiley", width: 8, height: 8,
                     data: [
                         [0,1,1,1,1,1,1,0],
                         [1,0,0,0,0,0,0,1],
                         [1,0,1,0,0,1,0,1],
                         [1,0,0,0,0,0,0,1],
                         [1,0,1,0,0,1,0,1],
                         [1,0,0,1,1,0,0,1],
                         [1,0,0,0,0,0,0,1],
                         [0,1,1,1,1,1,1,0]
                     ]
                 },
                 "heart": {
                    name: "heart", width: 7, height: 7,
                    data: [
                         [0,0,1,0,1,0,0],
                         [0,1,1,1,1,1,0],
                         [1,1,1,1,1,1,1],
                         [1,1,1,1,1,1,1],
                         [0,1,1,1,1,1,0],
                         [0,0,1,1,1,0,0],
                         [0,0,0,1,0,0,0]
                    ]
                 }
             };
            updateSpriteLibrarySelect(); // Populate sprite library dropdown

            // Initial draw
            draw();
            updatePropertiesPanel(); // Hide properties panel initially
            updateElementList(); // Populate element list
        }

         // Run initialization when the DOM is ready
        document.addEventListener('DOMContentLoaded', initialize);


    </script>

</body>
</html>
