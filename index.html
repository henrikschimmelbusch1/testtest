<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pico OLED UI Editor</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        #editor-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        #canvas-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #display-canvas {
            border: 1px solid #333;
            background-color: #000; /* Simulate OLED black background */
            image-rendering: optimizePixed; /* Keep pixels sharp */
            image-rendering: pixelated;
            width: 512px; /* Scaled up for visibility (128 * 4) */
            height: 256px; /* Scaled up for visibility (64 * 4) */
            cursor: crosshair;
        }
        #mouse-coords {
            margin-top: 5px;
            font-size: 0.9em;
            color: #555;
        }
        #controls-area {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .tool-bar, .properties-panel, .animation-panel, .sprite-editor-panel {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        .tool-bar h3, .properties-panel h3, .animation-panel h3, .sprite-editor-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .tool-bar button, .properties-panel button, .animation-panel button, #sprite-editor button {
            margin: 2px;
            padding: 8px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #eee;
            border-radius: 3px;
        }
        .tool-bar button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .properties-panel div, .animation-panel div, #sprite-editor label {
            margin-bottom: 10px;
        }
        .properties-panel input[type="number"],
        .properties-panel input[type="text"],
        .properties-panel select,
        .animation-panel input[type="number"] {
            width: calc(100% - 12px);
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .properties-panel input[type="checkbox"] {
            margin-right: 5px;
        }

        #code-output-area {
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        #generated-code {
            width: calc(100% - 20px);
            height: 300px;
            border: 1px solid #ccc;
            padding: 10px;
            font-family: monospace;
            white-space: pre;
            overflow: auto;
            background-color: #f9f9f9;
        }

        /* Sprite Editor Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover, .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        #sprite-editor-grid {
            display: grid;
            border: 1px solid #ccc;
            margin: 10px auto;
        }
        #sprite-editor-grid .pixel {
            width: 15px;
            height: 15px;
            border: 1px solid #eee;
            background-color: white; /* White represents off */
        }
        #sprite-editor-grid .pixel.on {
            background-color: black; /* Black represents on */
        }
        #sprite-editor-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
         .grid-option {
             margin-bottom: 10px;
         }
         .grid-option input {
             margin-left: 5px;
         }
         .element-list-item {
             padding: 5px;
             border-bottom: 1px solid #eee;
             cursor: pointer;
         }
        .element-list-item.selected {
            background-color: #e0f2ff;
        }
        #element-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 3px;
        }

    </style>
</head>
<body>

    <h1>Pico OLED UI Editor (128x64)</h1>

    <div id="editor-container">
        <div id="canvas-area">
            <canvas id="display-canvas" width="128" height="64"></canvas>
            <div id="mouse-coords">(0, 0)</div>
            <div class="grid-option">
                <label for="show-grid">Show Grid</label>
                <input type="checkbox" id="show-grid">
                <label for="snap-grid">Snap to Grid</label>
                <input type="checkbox" id="snap-grid">
            </div>
        </div>

        <div id="controls-area">
            <div class="tool-bar">
                <h3>Tools</h3>
                <button id="tool-select" class="active">Select</button>
                <button id="tool-pixel">Pixel</button>
                <button id="tool-line">Line</button>
                <button id="tool-rect">Rect</button>
                <button id="tool-filled-rect">Filled Rect</button>
                <button id="tool-circle">Circle</button>
                <button id="tool-filled-circle">Filled Circle</button>
                <button id="tool-text">Text</button>
                <button id="tool-sprite">Sprite</button>
                 <button id="tool-eraser">Eraser</button>
            </div>

             <div class="properties-panel">
                <h3>Element Properties</h3>
                 <div id="no-element-selected">Select an element to see properties.</div>
                <div id="selected-element-properties" style="display: none;">
                    <div>
                        <label for="prop-type">Type:</label>
                        <span id="prop-type"></span>
                    </div>
                     <div>
                        <label for="prop-x">X:</label>
                        <input type="number" id="prop-x" value="0">
                    </div>
                    <div>
                        <label for="prop-y">Y:</label>
                        <input type="number" id="prop-y" value="0">
                    </div>
                     <div class="prop-text">
                        <label for="prop-text-content">Text:</label>
                        <input type="text" id="prop-text-content" value="">
                     </div>
                     <div class="prop-size">
                        <label for="prop-width">Width:</label>
                        <input type="number" id="prop-width" value="10">
                    </div>
                    <div class="prop-size">
                        <label for="prop-height">Height:</label>
                        <input type="number" id="prop-height" value="10">
                    </div>
                     <div class="prop-radius">
                        <label for="prop-radius">Radius:</label>
                        <input type="number" id="prop-radius" value="5">
                     </div>
                    <div class="prop-color">
                         <label for="prop-color">Color:</label>
                        <select id="prop-color">
                            <option value="1">On (Black/White)</option>
                            <option value="0">Off (White/Black)</option>
                        </select>
                     </div>
                    <div class="prop-fill">
                        <label for="prop-fill">Filled:</label>
                        <input type="checkbox" id="prop-fill">
                    </div>
                     <div class="prop-sprite">
                         <label>Sprite:</label>
                         <button id="edit-sprite-button">Edit Sprite Data</button>
                     </div>
                     <button id="delete-element-button" style="background-color: #dc3545; color: white; border-color: #dc3545;">Delete Element</button>
                </div>
            </div>

            <div class="animation-panel">
                 <h3>Animation (Preview Only)</h3>
                <div id="no-anim-element-selected">Select an element to add animation.</div>
                 <div id="selected-anim-controls" style="display: none;">
                     <p>Define a simple path animation (start = current pos)</p>
                     <div>
                         <label for="anim-end-x">End X:</label>
                         <input type="number" id="anim-end-x" value="0">
                     </div>
                     <div>
                         <label for="anim-end-y">End Y:</label>
                         <input type="number" id="anim-end-y" value="0">
                     </div>
                     <div>
                         <label for="anim-steps">Steps:</label>
                         <input type="number" id="anim-steps" value="50" min="1">
                     </div>
                     <button id="add-animation-button">Set Animation</button>
                     <button id="remove-animation-button" style="background-color: #ffc107; border-color: #ffc107;">Remove Animation</button>
                     <button id="play-animation-button" style="background-color: #28a745; color: white; border-color: #28a745;">Play Animation</button>
                     <button id="stop-animation-button" style="background-color: #dc3545; color: white; border-color: #dc3545;">Stop Animation</button>
                 </div>
             </div>

             <div class="properties-panel">
                 <h3>Layers</h3>
                 <div id="element-list">
                     <!-- Element list will be populated here -->
                 </div>
                 <button id="move-up-button">Move Up</button>
                 <button id="move-down-button">Move Down</button>
             </div>

            <div class="tool-bar">
                <h3>Code</h3>
                <button id="generate-code-button">Generate MicroPython Code</button>
            </div>
        </div>
    </div>

    <div id="code-output-area">
        <h2>Generated MicroPython Code</h2>
        <pre id="generated-code"></pre>
    </div>

    <!-- Sprite Editor Modal -->
    <div id="spriteEditorModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h3>Sprite Editor (<span id="current-sprite-name">New Sprite</span>)</h3>
            <div>
                <label for="sprite-editor-width">Width:</label>
                <input type="number" id="sprite-editor-width" value="8" min="1" max="32">
                <label for="sprite-editor-height" style="margin-left: 10px;">Height:</label>
                <input type="number" id="sprite-editor-height" value="8" min="1" max="32">
                <button id="resize-sprite-grid">Resize Grid</button>
            </div>
            <div id="sprite-editor-grid">
                <!-- Pixel grid will be generated here -->
            </div>
            <div id="sprite-editor-controls">
                <button id="new-sprite-button">New Sprite</button>
                 <label for="sprite-name">Name:</label>
                 <input type="text" id="sprite-name" value="new_sprite">
                <button id="save-sprite-button">Save Sprite</button>
                <select id="sprite-library-select">
                    <option value="">-- Load Sprite --</option>
                </select>
                 <button id="load-sprite-button">Load Selected</button>
            </div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const DISPLAY_WIDTH = 128;
        const DISPLAY_HEIGHT = 64;
        const SCALE = 4; // For canvas display size
        const GRID_SIZE = 8; // Grid snap size

        // --- DOM Elements ---
        const canvas = document.getElementById('display-canvas');
        const ctx = canvas.getContext('2d');
        const mouseCoordsDiv = document.getElementById('mouse-coords');
        const toolButtons = document.querySelectorAll('.tool-bar button');
        const propertiesPanel = document.getElementById('selected-element-properties');
        const noElementSelectedMsg = document.getElementById('no-element-selected');
        const propTypeSpan = document.getElementById('prop-type');
        const propXInput = document.getElementById('prop-x');
        const propYInput = document.getElementById('prop-y');
        const propTextDiv = document.querySelector('.prop-text');
        const propTextContentInput = document.getElementById('prop-text-content');
        const propSizeDivs = document.querySelectorAll('.prop-size');
        const propWidthInput = document.getElementById('prop-width');
        const propHeightInput = document.getElementById('prop-height');
        const propRadiusDiv = document.querySelector('.prop-radius');
        const propRadiusInput = document.getElementById('prop-radius');
        const propColorDiv = document.querySelector('.prop-color');
        const propColorSelect = document.getElementById('prop-color');
        const propFillDiv = document.querySelector('.prop-fill');
        const propFillCheckbox = document.getElementById('prop-fill');
        const propSpriteDiv = document.querySelector('.prop-sprite');
        const deleteElementButton = document.getElementById('delete-element-button');
        const generateCodeButton = document.getElementById('generate-code-button');
        const generatedCodePre = document.getElementById('generated-code');
        const showGridCheckbox = document.getElementById('show-grid');
        const snapGridCheckbox = document.getElementById('snap-grid');
        const elementListDiv = document.getElementById('element-list');
        const moveUpButton = document.getElementById('move-up-button');
        const moveDownButton = document.getElementById('move-down-button');

        // Animation Controls
        const animPanel = document.querySelector('.animation-panel');
        const noAnimSelectedMsg = document.getElementById('no-anim-element-selected');
        const selectedAnimControls = document.getElementById('selected-anim-controls');
        const animEndXInput = document.getElementById('anim-end-x');
        const animEndYInput = document.getElementById('anim-end-y');
        const animStepsInput = document.getElementById('anim-steps');
        const addAnimationButton = document.getElementById('add-animation-button');
        const removeAnimationButton = document.getElementById('remove-animation-button');
        const playAnimationButton = document.getElementById('play-animation-button');
        const stopAnimationButton = document.getElementById('stop-animation-button');


        // Sprite Editor Modal
        const spriteEditorModal = document.getElementById('spriteEditorModal');
        const closeModalSpan = document.querySelector('.modal .close');
        const spriteEditorGridDiv = document.getElementById('sprite-editor-grid');
        const spriteEditorWidthInput = document.getElementById('sprite-editor-width');
        const spriteEditorHeightInput = document.getElementById('sprite-editor-height');
        const resizeSpriteGridButton = document.getElementById('resize-sprite-grid');
        const newSpriteButton = document.getElementById('new-sprite-button');
        const saveSpriteButton = document.getElementById('save-sprite-button');
        const spriteLibrarySelect = document.getElementById('sprite-library-select');
        const loadSpriteButton = document.getElementById('load-sprite-button');
        const currentSpriteNameSpan = document.getElementById('current-sprite-name');
        const spriteNameInput = document.getElementById('sprite-name');
        const editSpriteButton = document.getElementById('edit-sprite-button');


        // --- State Variables ---
        let elements = []; // Array to store all drawn elements
        let spriteLibrary = {}; // Object to store named sprite data
        let selectedTool = 'select';
        let selectedElement = null;
        let dragInfo = null; // { element: ..., offsetX: ..., offsetY: ..., startX: ..., startY: ..., type: 'move' | 'resize' }
        let drawingShape = null; // { type: ..., startX: ..., startY: ..., currentX: ..., currentY: ... }
        let animationFrameId = null; // For animation preview

        // --- Grid/Snap State ---
        let showGrid = false;
        let snapGrid = false;

        // --- Sprite Editor State ---
        let currentSpriteData = null; // 2D array [y][x] of 0 or 1
        let currentSpriteName = 'new_sprite';


        // --- Drawing Functions ---
        function drawPixel(x, y, color) {
            // Clamp coordinates to display boundaries
            x = Math.max(0, Math.min(x, DISPLAY_WIDTH - 1));
            y = Math.max(0, Math.min(y, DISPLAY_HEIGHT - 1));
            ctx.fillStyle = color === 1 ? 'white' : 'black'; // SSD1306 "on" pixel is typically bright (white on black display)
            ctx.fillRect(x, y, 1, 1);
        }

        function drawLine(x0, y0, x1, y1, color) {
            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }

        function drawRect(x, y, w, h, color, fill = false) {
             // Clamp coordinates and size
            x = Math.max(0, x);
            y = Math.max(0, y);
            w = Math.min(w, DISPLAY_WIDTH - x);
            h = Math.min(h, DISPLAY_HEIGHT - y);

            if (w <= 0 || h <= 0) return;

            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.fillStyle = color === 1 ? 'white' : 'black';

            if (fill) {
                ctx.fillRect(x, y, w, h);
            } else {
                ctx.strokeRect(x, y, w, h);
            }
        }

        function drawCircle(cx, cy, r, color, fill = false) {
            // Clamp center and radius - simple clamp might clip.
            // For simplicity, just draw if center is within bounds. Clipping is more complex.
             if (cx < -r || cx > DISPLAY_WIDTH + r || cy < -r || cy > DISPLAY_HEIGHT + r) return;

            ctx.strokeStyle = color === 1 ? 'white' : 'black';
            ctx.fillStyle = color === 1 ? 'white' : 'black';

            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);

            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

         function drawText(text, x, y, color) {
            // Text positioning is tricky on pixel displays. (x,y) is often top-left or baseline.
            // MicroPython framebuf uses (x,y) as top-left of the text bounding box. We'll simulate that.
             if (x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return; // Simple clipping

            ctx.fillStyle = color === 1 ? 'white' : 'black';
            // Use a simple monospace font matching typical display fonts
            ctx.font = '8px monospace'; // Assume 8px height for typical fonts

            // Ensure text stays within bounds horizontally
             let clippedText = text;
             let textMetrics = ctx.measureText(clippedText);
             while(x + textMetrics.width > DISPLAY_WIDTH && clippedText.length > 0) {
                 clippedText = clippedText.slice(0, -1);
                 textMetrics = ctx.measureText(clippedText);
             }
             if (clippedText.length === 0) return; // Text is too long to fit

            // Vertical position: MicroPython text often draws from the top-left of the character box.
            // Canvas drawText y is typically the baseline. We need to adjust.
            // A common font height is 8px. Let's assume that and adjust.
            const fontHeight = 8;
            const adjustedY = y + fontHeight; // Draw baseline at y + fontHeight

            // Only draw if at least part of the text is within vertical bounds
             if (adjustedY >= 0 && y < DISPLAY_HEIGHT) {
                ctx.fillText(clippedText, x, adjustedY);
             }
        }

        function drawSprite(x, y, spriteData, color) {
            if (!spriteData || spriteData.length === 0) return;

            const spriteHeight = spriteData.length;
            const spriteWidth = spriteData[0].length;

             // Clamp sprite position - simple clipping
             x = Math.max(0, x);
             y = Math.max(0, y);

            for (let j = 0; j < spriteHeight; j++) {
                for (let i = 0; i < spriteWidth; i++) {
                    // Only draw if pixel is 'on' (1), within sprite bounds, and within display bounds
                    if (spriteData[j] && spriteData[j][i] === 1) {
                         if (x + i < DISPLAY_WIDTH && y + j < DISPLAY_HEIGHT) {
                             drawPixel(x + i, y + j, color);
                         }
                    }
                }
            }
        }


        function drawGrid() {
            if (!showGrid) return;

            ctx.strokeStyle = '#111'; // Dark grey/black for grid lines on black background
            ctx.lineWidth = 0.5;

            // Vertical lines
            for (let x = 0; x < DISPLAY_WIDTH; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, DISPLAY_HEIGHT);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < DISPLAY_HEIGHT; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(DISPLAY_WIDTH, y);
                ctx.stroke();
            }
             ctx.lineWidth = 1; // Reset line width
        }

         function drawBoundingBox(element) {
             ctx.strokeStyle = 'red'; // Highlight color
             ctx.lineWidth = 1;
             ctx.setLineDash([2, 2]); // Dashed line

             let x, y, w, h;
             const padding = 1; // Small padding around the element

             switch (element.type) {
                 case 'pixel':
                     x = element.x - padding;
                     y = element.y - padding;
                     w = 1 + 2 * padding;
                     h = 1 + 2 * padding;
                     break;
                 case 'line':
                     // Bounding box of a line is min/max x,y
                     x = Math.min(element.x1, element.x2) - padding;
                     y = Math.min(element.y1, element.y2) - padding;
                     w = Math.abs(element.x1 - element.x2) + 1 + 2 * padding;
                     h = Math.abs(element.y1 - element.y2) + 1 + 2 * padding;
                     break;
                 case 'rect':
                 case 'filled-rect':
                     x = element.x - padding;
                     y = element.y - padding;
                     w = element.width + 2 * padding;
                     h = element.height + 2 * padding;
                     break;
                 case 'circle':
                 case 'filled-circle':
                      // Bounding box of a circle
                     x = element.cx - element.r - padding;
                     y = element.cy - element.r - padding;
                     w = element.r * 2 + 2 * padding;
                     h = element.r * 2 + 2 * padding;
                     break;
                 case 'text':
                      // Simple bounding box for text based on estimated font size
                     const textWidth = element.text.length * 8; // Estimate width assuming 8px wide chars
                     const textHeight = 8; // Estimate height
                     x = element.x - padding;
                     y = element.y - padding;
                     w = textWidth + 2 * padding;
                     h = textHeight + 2 * padding;
                     break;
                 case 'sprite':
                     const sprite = spriteLibrary[element.spriteDataRef];
                     if (!sprite) return;
                     x = element.x - padding;
                     y = element.y - padding;
                     w = sprite.width + 2 * padding;
                     h = sprite.height + 2 * padding;
                     break;
                 default:
                     return; // Don't draw box for unknown types
             }

             // Adjust clamped box to canvas bounds
             x = Math.max(0, x);
             y = Math.max(0, y);
             w = Math.min(w, DISPLAY_WIDTH - x);
             h = Math.min(h, DISPLAY_HEIGHT - y);


             ctx.strokeRect(x, y, w, h);

             ctx.setLineDash([]); // Reset line dash
             ctx.lineWidth = 1; // Reset line width
         }


        function draw() {
            ctx.clearRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT); // Fill background

            if (showGrid) {
                drawGrid();
            }

            elements.forEach(el => {
                // Check if element has animation data and update position if animation is playing (JS preview)
                if (el.animation && el.animation.progress !== undefined) {
                     const currentStep = el.animation.progress;
                     const totalSteps = el.animation.steps;
                     const startX = el.animation.startX;
                     const startY = el.animation.startY;
                     const endX = el.animation.endX;
                     const endY = el.animation.endY;

                     // Linear interpolation
                     el._currentRenderX = startX + (endX - startX) * (currentStep / totalSteps);
                     el._currentRenderY = startY + (endY - startY) * (currentStep / totalSteps);
                } else {
                    // Use stored x, y if no animation is active
                    el._currentRenderX = el.x;
                    el._currentRenderY = el.y;
                }


                // Draw element based on type
                switch (el.type) {
                    case 'pixel':
                         drawPixel(el._currentRenderX, el._currentRenderY, el.color);
                        break;
                    case 'line':
                         // The _currentRenderX/Y tracks the movement of the "origin" point (x,y for rect, cx,cy for circle, x for text/sprite).
                         // For a line, we need to shift both start and end points by the delta movement of the 'origin'.
                         // We stored the line's original x1, y1 in el.x1, el.y1.
                         // We stored the animation's *start* position in el.animation.startX, el.animation.startY (which should be == original el.x1, el.y1 if anim was set immediately).
                         // The element._currentRenderX/Y are the *current* animated position.
                         // The delta movement is (current - original_anim_start)
                         const deltaX = el._currentRenderX - (el.animation?.startX ?? el.x1); // Use original if no anim
                         const deltaY = el._currentRenderY - (el.animation?.startY ?? el.y1); // Use original if no anim

                         drawLine(el.x1 + deltaX, el.y1 + deltaY, el.x2 + deltaX, el.y2 + deltaY, el.color);

                        break;
                    case 'rect':
                    case 'filled-rect':
                         drawRect(el._currentRenderX, el._currentRenderY, el.width, el.height, el.color, el.fill);
                        break;
                    case 'circle':
                    case 'filled-circle':
                         // The _currentRenderX/Y is the animated *center* (cx, cy) for circles
                         drawCircle(el._currentRenderX, el._currentRenderY, el.radius, el.color, el.fill);
                        break;
                    case 'text':
                         drawText(el._currentRenderX, el._currentRenderY, el.text, el.color);
                        break;
                    case 'sprite':
                        const spriteData = spriteLibrary[el.spriteDataRef];
                         if (spriteData) {
                            drawSprite(el._currentRenderX, el._currentRenderY, spriteData.data, el.color);
                         } else {
                             console.error(`Sprite data not found for reference: ${el.spriteDataRef}`);
                         }
                        break;
                }
            });

             // Draw bounding box for the selected element AFTER drawing all elements
             if (selectedElement) {
                 drawBoundingBox(selectedElement);
             }
        }

        // --- Helper Functions ---

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (event.clientX - rect.left) * scaleX;
            let y = (event.clientY - rect.top) * scaleY;

             // Apply snap only when selecting/moving or drawing start points
             if (snapGrid && (selectedTool === 'select' || (drawingShape && !drawingShape.endX && !drawingShape.endY))) {
                 x = Math.round(x / GRID_SIZE) * GRID_SIZE;
                 y = Math.round(y / GRID_SIZE) * GRID_SIZE;
             }

            // Clamp to canvas boundaries
            x = Math.max(0, Math.min(x, DISPLAY_WIDTH - (selectedTool === 'pixel' || selectedTool === 'eraser' ? 1 : 0))); // Clamp pixel exactly
            y = Math.max(0, Math.min(y, DISPLAY_HEIGHT - (selectedTool === 'pixel' || selectedTool === 'eraser' ? 1 : 0))); // Clamp pixel exactly

            return { x: Math.round(x), y: Math.round(y) };
        }

         function updateMouseCoordinates(event) {
            const pos = getMousePos(event);
            mouseCoordsDiv.textContent = `(${pos.x}, ${pos.y})`;
        }

         function selectTool(tool) {
            selectedTool = tool;
            toolButtons.forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tool-${tool}`).classList.add('active');
            // Reset drawing state when tool changes
             drawingShape = null;
            // Deselect element unless the new tool is 'select' and an element is already selected
             if (tool !== 'select' || !selectedElement) {
                 selectElement(null);
             }
         }

         function updatePropertiesPanel() {
             if (selectedElement) {
                 noElementSelectedMsg.style.display = 'none';
                 propertiesPanel.style.display = 'block';

                 propTypeSpan.textContent = selectedElement.type;
                 // Use original x,y from storage, not the potentially animated _currentRenderX/Y
                 propXInput.value = selectedElement.type === 'line' ? selectedElement.x1 : (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.x : selectedElement.x);
                 propYInput.value = selectedElement.type === 'line' ? selectedElement.y1 : (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.y : selectedElement.y);


                 // Hide/show specific properties based on element type
                 propTextDiv.style.display = (selectedElement.type === 'text') ? 'block' : 'none';
                 // propSizeDivs applies to rect and sprite base dimensions
                 propSizeDivs.forEach(div => div.style.display = (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect' || selectedElement.type === 'sprite') ? 'block' : 'none');
                 propRadiusDiv.style.display = (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') ? 'block' : 'none';
                 propColorDiv.style.display = (selectedElement.type !== 'sprite') ? 'block' : 'none'; // Sprites use the sprite element's color
                 propFillDiv.style.display = (selectedElement.type === 'rect' || selectedElement.type === 'circle') ? 'block' : 'none'; // Only rect/circle have fill option

                 // Sprite specific property
                 propSpriteDiv.style.display = (selectedElement.type === 'sprite') ? 'block' : 'none';


                 // Update input values
                 if (selectedElement.type === 'text') propTextContentInput.value = selectedElement.text;
                 if (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect' || selectedElement.type === 'sprite') {
                      if (selectedElement.type === 'sprite') {
                          const sprite = spriteLibrary[selectedElement.spriteDataRef];
                           if(sprite) {
                                // Display sprite dimensions but disable editing
                                propWidthInput.value = sprite.width;
                                propHeightInput.value = sprite.height;
                                propWidthInput.disabled = true;
                                propHeightInput.disabled = true;
                           } else {
                                propWidthInput.value = 0; propHeightInput.value = 0;
                                propWidthInput.disabled = true; propHeightInput.disabled = true;
                           }
                      } else {
                        propWidthInput.value = selectedElement.width;
                        propHeightInput.value = selectedElement.height;
                         propWidthInput.disabled = false;
                         propHeightInput.disabled = false;
                      }
                 }
                 if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') propRadiusInput.value = selectedElement.radius;
                 // Only update color picker if element has a color property (non-sprite)
                 if (selectedElement.hasOwnProperty('color')) propColorSelect.value = selectedElement.color;
                 if (selectedElement.type === 'rect' || selectedElement.type === 'circle') propFillCheckbox.checked = selectedElement.fill;

                 // Update animation panel
                 updateAnimationPanel();

             } else {
                 noElementSelectedMsg.style.display = 'block';
                 propertiesPanel.style.display = 'none';
                 updateAnimationPanel(); // Hide animation controls too
             }
         }

         function updateAnimationPanel() {
             if (selectedElement && (selectedElement.type !== 'pixel' && selectedElement.type !== 'line')) { // Animation is only supported for elements with a clear 'origin' point (x,y, cx,cy)
                 noAnimSelectedMsg.style.display = 'none';
                 selectedAnimControls.style.display = 'block';

                 // Get the appropriate start X/Y for animation based on element type
                 const elementOriginX = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cx : selectedElement.x;
                 const elementOriginY = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cy : selectedElement.y;


                 // Show animation data if exists, otherwise show default values
                 if (selectedElement.animation) {
                     animEndXInput.value = selectedElement.animation.endX;
                     animEndYInput.value = selectedElement.animation.endY;
                     animStepsInput.value = selectedElement.animation.steps;
                     addAnimationButton.style.display = 'none';
                     removeAnimationButton.style.display = 'inline-block';
                 } else {
                     // Default end position to current + offset
                     animEndXInput.value = elementOriginX + 10;
                     animEndYInput.value = elementOriginY;
                     animStepsInput.value = 50;
                      addAnimationButton.style.display = 'inline-block';
                     removeAnimationButton.style.display = 'none';
                 }

             } else {
                 noAnimSelectedMsg.style.display = 'block';
                 selectedAnimControls.style.display = 'none';
             }
             // Animation preview controls are always visible if controls are visible,
             // but play/stop only work if animation data is set.
             playAnimationButton.disabled = !selectedElement || !selectedElement.animation;
             stopAnimationButton.disabled = animationFrameId === null; // Stop only active when playing
         }


         function updateElementList() {
             elementListDiv.innerHTML = '';
             // Iterate in reverse order to show top layer at the top of the list
             for (let i = elements.length - 1; i >= 0; i--) {
                 const el = elements[i];
                 const item = document.createElement('div');
                 item.classList.add('element-list-item');
                 if (el === selectedElement) {
                     item.classList.add('selected');
                 }
                 let label = `${el.type}`;
                 if (el.type === 'text') label += ` ("${el.text.substring(0, 15)}...")`;
                 if (el.type === 'sprite' && spriteLibrary[el.spriteDataRef]) label += ` (${el.spriteDataRef})`;

                 // Show original position in list label
                 const originalX = el.type === 'line' ? el.x1 : (el.type === 'circle' || el.type === 'filled-circle' ? el.x : el.x);
                 const originalY = el.type === 'line' ? el.y1 : (el.type === 'circle' || el.type === 'filled-circle' ? el.y : el.y);

                 label += ` @ (${originalX},${originalY})`;
                 item.textContent = `${elements.length - 1 - i}: ${label}`; // Display layer number (0 is top)
                 item.dataset.index = i; // Store actual index for manipulation
                 item.addEventListener('click', () => {
                     selectElement(elements[parseInt(item.dataset.index)]); // Select element using its current index
                 });
                 elementListDiv.appendChild(item);
             }

             // Disable move buttons if no element selected or at list boundary
             const selectedIndex = elements.indexOf(selectedElement);
             moveUpButton.disabled = !selectedElement || selectedIndex === elements.length - 1; // "Up" in list is moving towards index 0
             moveDownButton.disabled = !selectedElement || selectedIndex === 0; // "Down" in list is moving towards last index
         }

         function selectElement(element) {
             if (selectedElement === element) return; // Avoid re-selecting the same element

             // Stop any ongoing animation when selecting a new element
             stopAnimationPreview();

             selectedElement = element;
             updatePropertiesPanel();
             updateElementList();
             draw(); // Redraw to show/hide bounding box
         }


         function isPointInElement(x, y, element) {
            // Simple hit-testing based on bounding boxes
            switch (element.type) {
                case 'pixel':
                    return x === element.x && y === element.y;
                case 'line':
                    // More complex: check distance to line segment. For simplicity, check bounding box.
                     let minX = Math.min(element.x1, element.x2);
                     let maxX = Math.max(element.x1, element.x2);
                     let minY = Math.min(element.y1, element.y2);
                     let maxY = Math.max(element.y1, element.y2);
                     // Add a small tolerance for easier clicking
                     const tolerance = 2;
                     return x >= minX - tolerance && x <= maxX + tolerance && y >= minY - tolerance && y <= maxY + tolerance;
                case 'rect':
                case 'filled-rect':
                     return x >= element.x && x < element.x + element.width && y >= element.y && y < element.y + element.height;
                case 'circle':
                case 'filled-circle':
                     // Check if point is within radius of center
                     const dx = x - element.cx;
                     const dy = y - element.cy;
                     return dx * dx + dy * dy <= element.radius * element.radius;
                 case 'text':
                     // Simple bounding box for text
                     const textWidth = element.text.length * 8; // Estimate assuming 8px wide chars
                     const textHeight = 8; // Estimate height
                     return x >= element.x && x < element.x + textWidth && y >= element.y && y < element.y + textHeight;
                 case 'sprite':
                     const sprite = spriteLibrary[element.spriteDataRef];
                     if (!sprite) return false;
                     return x >= element.x && x < element.x + sprite.width && y >= element.y && y < element.y + sprite.height;
                default:
                    return false;
            }
         }

        function snapToGrid(x, y) {
            if (!snapGrid) return { x, y };
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }


         // --- Event Handlers ---

         canvas.addEventListener('mousemove', (event) => {
             updateMouseCoordinates(event);
             const pos = getMousePos(event);

             // If drawing a shape, update its dimensions and redraw
             if (drawingShape) {
                 drawingShape.currentX = pos.x;
                 drawingShape.currentY = pos.y;
                 draw(); // Redraw with the current drawing shape
             } else if (dragInfo) {
                 // Moving an element
                 let newX = pos.x - dragInfo.offsetX;
                 let newY = pos.y - dragInfo.offsetY;

                 // Apply snapping if enabled
                 if (snapGrid) {
                      const snappedPos = snapToGrid(newX, newY);
                      newX = snappedPos.x;
                      newY = snappedPos.y;
                 }

                 // Update element's position based on its type's origin point
                 if (dragInfo.element.type === 'line') {
                     const dx = newX - dragInfo.element.x1; // Delta from the line's start point
                     const dy = newY - dragInfo.element.y1;
                     dragInfo.element.x1 = newX;
                     dragInfo.element.y1 = newY;
                     dragInfo.element.x2 += dx;
                     dragInfo.element.y2 += dy;
                 } else if (dragInfo.element.type === 'circle' || dragInfo.element.type === 'filled-circle') {
                     // dragInfo.offsetX/Y stored the offset from the circle's center (cx,cy)
                     const newCx = pos.x - dragInfo.offsetX;
                     const newCy = pos.y - dragInfo.offsetY;
                      // Apply snap to the center point if enabled
                      const snappedCenter = snapGrid ? snapToGrid(newCx, newCy) : {x: newCx, y: newCy};
                      dragInfo.element.cx = snappedCenter.x;
                      dragInfo.element.cy = snappedCenter.y;
                      // Update stored x,y (top-left of bounding box) based on new center
                      dragInfo.element.x = snappedCenter.x - dragInfo.element.radius;
                      dragInfo.element.y = snappedCenter.y - dragInfo.element.radius;

                 } else {
                      // dragInfo.offsetX/Y stored the offset from the element's top-left (x,y)
                      const snappedPos = snapGrid ? snapToGrid(pos.x - dragInfo.offsetX, pos.y - dragInfo.offsetY) : {x: pos.x - dragInfo.offsetX, y: pos.y - dragInfo.offsetY};
                      dragInfo.element.x = snappedPos.x;
                      dragInfo.element.y = snappedPos.y;
                 }

                 // Update properties panel if the dragged element is the selected one
                 if (dragInfo.element === selectedElement) {
                     updatePropertiesPanel();
                 }

                 draw(); // Redraw to show the element moving
             }
         });

         canvas.addEventListener('mousedown', (event) => {
             const pos = getMousePos(event);

             if (selectedTool === 'select') {
                 // Check if clicking on an existing element (iterate in reverse order for layers)
                 let clickedElement = null;
                 for (let i = elements.length - 1; i >= 0; i--) {
                     if (isPointInElement(pos.x, pos.y, elements[i])) {
                         clickedElement = elements[i];
                         break;
                     }
                 }

                 if (clickedElement) {
                     selectElement(clickedElement);
                     // Start drag operation
                      let dragStartX, dragStartY;
                      if (clickedElement.type === 'line') {
                           // Drag reference is the line's start point (x1, y1)
                           dragStartX = clickedElement.x1;
                           dragStartY = clickedElement.y1;
                      } else if (clickedElement.type === 'circle' || clickedElement.type === 'filled-circle') {
                           // Drag reference is the circle's center (cx, cy)
                           dragStartX = clickedElement.cx;
                           dragStartY = clickedElement.cy;
                      } else {
                           // Drag reference is the element's top-left (x, y)
                           dragStartX = clickedElement.x;
                           dragStartY = clickedElement.y;
                      }

                     dragInfo = {
                         element: clickedElement,
                         offsetX: pos.x - dragStartX,
                         offsetY: pos.y - dragStartY,
                         startX: dragStartX, // Store initial position of the drag reference point
                         startY: dragStartY,
                         type: 'move' // Could add 'resize' later
                     };


                 } else {
                     // Clicked outside elements, deselect
                     selectElement(null);
                     dragInfo = null; // No drag started
                 }
             } else if (selectedTool === 'pixel') {
                 elements.push({ type: 'pixel', x: pos.x, y: pos.y, color: parseInt(propColorSelect.value) }); // Use selected color
                 draw();
                 updateElementList();
             } else if (selectedTool === 'eraser') {
                 // Remove pixel if one exists at this location
                 const initialLength = elements.length;
                  // Iterate in reverse to safely remove and hit top layer first
                 for (let i = elements.length - 1; i >= 0; i--) {
                      const el = elements[i];
                      if (el.type === 'pixel' && el.x === pos.x && el.y === pos.y) {
                         elements.splice(i, 1);
                         // If the deleted element was selected, deselect it
                         if (el === selectedElement) {
                             selectElement(null);
                         }
                         break; // Assume only one pixel element per coordinate for simplicity
                      }
                 }

                 if (elements.length < initialLength) {
                     draw();
                     updateElementList();
                 }
             } else if (selectedTool === 'sprite' && currentSpriteData && currentSpriteName && spriteLibrary[currentSpriteName]) {
                  // Place the currently saved sprite
                  const sprite = spriteLibrary[currentSpriteName];
                  elements.push({ type: 'sprite', x: pos.x, y: pos.y, spriteDataRef: currentSpriteName, color: parseInt(propColorSelect.value) }); // Sprites use a reference and a color tint
                  draw();
                  updateElementList();
             }
             else {
                 // Start drawing a shape
                 drawingShape = {
                     type: selectedTool, // e.g., 'line', 'rect', 'circle', 'filled-rect', 'filled-circle', 'text' (temp)
                     startX: pos.x,
                     startY: pos.y,
                     currentX: pos.x,
                     currentY: pos.y,
                     color: parseInt(propColorSelect.value), // Get color from controls
                     fill: selectedTool.startsWith('filled-')
                 };

                 // Handle Text tool start
                 if (selectedTool === 'text') {
                      // For text, mousedown just sets the position. The element is added on mouseup or a different action.
                      // Let's simplify: mousedown places text immediately.
                     const text = propTextContentInput.value || "Hello";
                     if (text) {
                         elements.push({ type: 'text', x: pos.x, y: pos.y, text: text, color: parseInt(propColorSelect.value) });
                         draw();
                         updateElementList();
                     }
                     drawingShape = null; // Text is placed instantly, not drawn with drag
                 }
             }
         });

         canvas.addEventListener('mouseup', (event) => {
             const pos = getMousePos(event);

             if (dragInfo) {
                 // End drag operation
                 dragInfo = null;
             } else if (drawingShape && drawingShape.type !== 'text') {
                 // End drawing a shape and add it to elements
                 const startX = drawingShape.startX;
                 const startY = drawingShape.startY;
                 const endX = pos.x; // Use final mouse position
                 const endY = pos.y;
                 const color = drawingShape.color;
                 const fill = drawingShape.fill;

                 let newElement = null;

                 switch (drawingShape.type) {
                     case 'line':
                         newElement = { type: 'line', x1: startX, y1: startY, x2: endX, y2: endY, color: color };
                         break;
                     case 'rect':
                     case 'filled-rect':
                         // Ensure width and height are positive, adjust x/y if dragging left/up
                         const x = Math.min(startX, endX);
                         const y = Math.min(startY, endY);
                         const width = Math.abs(startX - endX) + 1; // +1 to include the end pixel
                         const height = Math.abs(startY - endY) + 1; // +1 to include the end pixel
                         // Don't add zero-width/height rectangles
                         if (width > 0 && height > 0) {
                            newElement = { type: drawingShape.type, x: x, y: y, width: width, height: height, color: color, fill: fill };
                         }
                         break;
                      case 'circle':
                      case 'filled-circle':
                          // Define circle by center and radius. Let's treat start as center and end as a point on circumference.
                          const cx = drawingShape.startX;
                          const cy = drawingShape.startY;
                          const dx = endX - cx;
                          const dy = endY - cy;
                          const radius = Math.round(Math.sqrt(dx * dx + dy * dy));
                           // Don't add zero-radius circles
                           if (radius > 0) {
                               // Store center (cx, cy) and radius (r). Also store top-left (x,y) for consistent property panel/drag
                               newElement = {
                                    type: drawingShape.type,
                                    cx: cx,
                                    cy: cy,
                                    radius: radius,
                                    x: cx - radius, // Top-left of bounding box (for property panel consistency)
                                    y: cy - radius, // Top-left of bounding box (for property panel consistency)
                                    color: color,
                                    fill: fill
                               };
                           }
                          break;
                 }

                 if (newElement) {
                     elements.push(newElement);
                     selectElement(newElement); // Select the newly created element
                     updateElementList();
                 }

                 drawingShape = null; // Stop drawing mode
                 draw(); // Redraw with the finished shape
             }
         });

         canvas.addEventListener('mouseout', (event) => {
             mouseCoordsDiv.textContent = `(0, 0)`; // Reset coords when mouse leaves
         });

         // --- Property Panel Event Listeners ---
         propXInput.addEventListener('change', (event) => {
             if (selectedElement) {
                 const newX = parseInt(event.target.value);
                 if (isNaN(newX)) return;
                 // Update position based on element type's origin point
                  if (selectedElement.type === 'line') {
                       const dx = newX - selectedElement.x1;
                       selectedElement.x1 = newX;
                       selectedElement.x2 += dx;
                  } else if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') {
                       // Change x (top-left) updates cx, maintaining radius
                       const newCx = newX + selectedElement.radius;
                       selectedElement.x = newX; // Update stored top-left x
                       selectedElement.cx = newCx; // Update center x
                  }
                 else {
                    selectedElement.x = newX;
                 }
                 draw();
                 updateElementList(); // Update position in list label
             }
         });

         propYInput.addEventListener('change', (event) => {
            if (selectedElement) {
                 const newY = parseInt(event.target.value);
                  if (isNaN(newY)) return;
                 // Update position based on element type's origin point
                 if (selectedElement.type === 'line') {
                       const dy = newY - selectedElement.y1;
                       selectedElement.y1 = newY;
                       selectedElement.y2 += dy;
                 } else if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') {
                      // Change y (top-left) updates cy, maintaining radius
                      const newCy = newY + selectedElement.radius;
                      selectedElement.y = newY; // Update stored top-left y
                      selectedElement.cy = newCy; // Update center y
                 }
                 else {
                    selectedElement.y = newY;
                 }

                 draw();
                 updateElementList(); // Update position in list label
             }
         });

         propTextContentInput.addEventListener('change', (event) => {
             if (selectedElement && selectedElement.type === 'text') {
                 selectedElement.text = event.target.value;
                 draw();
                 updateElementList(); // Text content might affect list label
             }
         });

         propWidthInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect')) {
                 const newWidth = parseInt(event.target.value);
                  if (isNaN(newWidth) || newWidth < 0) return; // Prevent negative width
                 selectedElement.width = newWidth;
                 draw();
             }
         });

         propHeightInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'rect' || selectedElement.type === 'filled-rect')) {
                  const newHeight = parseInt(event.target.value);
                  if (isNaN(newHeight) || newHeight < 0) return; // Prevent negative height
                 selectedElement.height = newHeight;
                 draw();
             }
         });

         propRadiusInput.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle')) {
                 const newRadius = parseInt(event.target.value);
                  if (isNaN(newRadius) || newRadius < 0) return; // Prevent negative radius
                 selectedElement.radius = newRadius;
                 // Update stored x,y (top-left) based on new radius, keeping cx/cy
                 selectedElement.x = selectedElement.cx - newRadius;
                 selectedElement.y = selectedElement.cy - newRadius;
                 draw();
             }
         });

         propColorSelect.addEventListener('change', (event) => {
             if (selectedElement && selectedElement.hasOwnProperty('color')) { // Check if element type has a color property
                 selectedElement.color = parseInt(event.target.value);
                 draw();
             }
         });

         propFillCheckbox.addEventListener('change', (event) => {
             if (selectedElement && (selectedElement.type.startsWith('rect') || selectedElement.type.startsWith('circle'))) {
                 selectedElement.fill = event.target.checked;
                 // Update type name based on fill state
                 if (selectedElement.type === 'rect' && selectedElement.fill) selectedElement.type = 'filled-rect';
                 if (selectedElement.type === 'filled-rect' && !selectedElement.fill) selectedElement.type = 'rect';
                 if (selectedElement.type === 'circle' && selectedElement.fill) selectedElement.type = 'filled-circle';
                 if (selectedElement.type === 'filled-circle' && !selectedElement.fill) selectedElement.type = 'circle';
                 updatePropertiesPanel(); // Update type name shown
                 draw();
             }
         });

         deleteElementButton.addEventListener('click', () => {
            if (selectedElement) {
                const index = elements.indexOf(selectedElement);
                if (index !== -1) {
                    elements.splice(index, 1);
                    selectElement(null); // Deselect
                    draw();
                    updateElementList();
                }
            }
         });

         // --- Toolbar Button Event Listeners ---
         toolButtons.forEach(button => {
             if (button.id.startsWith('tool-')) {
                 button.addEventListener('click', () => {
                     selectTool(button.id.replace('tool-', ''));
                 });
             }
         });

         // --- Grid/Snap Event Listeners ---
         showGridCheckbox.addEventListener('change', (event) => {
             showGrid = event.target.checked;
             draw();
         });
          snapGridCheckbox.addEventListener('change', (event) => {
             snapGrid = event.target.checked;
             // No redraw needed, snap applies during mouse events
         });


         // --- Layer Controls ---
         moveUpButton.addEventListener('click', () => {
             if (selectedElement) {
                 const index = elements.indexOf(selectedElement);
                 // "Move Up" in the UI list means decreasing the index in the array (moving to an earlier position, drawn later)
                 if (index < elements.length - 1) {
                     // Swap elements
                     [elements[index], elements[index + 1]] = [elements[index + 1], elements[index]];
                     updateElementList();
                     draw(); // Redraw with new layer order
                     // Reselect the element to update button states and list highlighting
                     selectElement(selectedElement);
                 }
             }
         });

         moveDownButton.addEventListener('click', () => {
             if (selectedElement) {
                 const index = elements.indexOf(selectedElement);
                 // "Move Down" in the UI list means increasing the index in the array (moving to a later position, drawn earlier)
                 if (index > 0) {
                     // Swap elements
                     [elements[index], elements[index - 1]] = [elements[index - 1], elements[index]];
                     updateElementList();
                     draw(); // Redraw with new layer order
                      // Reselect the element to update button states and list highlighting
                     selectElement(selectedElement);
                 }
             }
         });


         // --- Animation Preview ---
         function playAnimationPreview() {
            if (!selectedElement || !selectedElement.animation) return;

            // Stop any existing animation preview first
            stopAnimationPreview();

            const anim = selectedElement.animation;
            anim.progress = 0; // Start at step 0
            // Store the element's current position as the animation start position
             anim.startX = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cx : selectedElement.x;
             anim.startY = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cy : selectedElement.y;


            // Make a deep copy of the initial state of *all* elements for consistent preview rendering frame by frame
             // Add temporary IDs if they don't exist, to find the element in the copied array
             elements.forEach(el => {
                  if (!el.id) el.id = Date.now() + Math.random();
             });
             const initialElementsState = JSON.parse(JSON.stringify(elements));

            function animate(currentTime) {
                // Find the animating element in the initial state copy
                const elementToAnimateInitial = initialElementsState.find(el => el.id === selectedElement.id);

                if (!elementToAnimateInitial) {
                     console.error("Animating element not found in initial state copy!");
                     stopAnimationPreview();
                     return;
                }

                 anim.progress++; // Increment step

                if (anim.progress <= anim.steps) {
                    // Create a fresh copy of the initial state for each frame
                     const currentFrameElements = JSON.parse(JSON.stringify(initialElementsState));
                    // Find the animating element in the current frame's state copy using its ID
                    const elementToAnimateThisFrame = currentFrameElements.find(el => el.id === selectedElement.id);

                    if (elementToAnimateThisFrame) {
                         const currentStep = anim.progress;
                         const totalSteps = anim.steps;

                          // Calculate new position using linear interpolation based on animation's start/end points
                         const currentX = anim.startX + (anim.endX - anim.startX) * (currentStep / totalSteps);
                         const currentY = anim.startY + (anim.endY - anim.startY) * (currentStep / totalSteps);

                          // Update the element's position properties *in the frame's copy*
                         if (elementToAnimateThisFrame.type === 'line') {
                             // Move both points relative to the start point's movement
                             const originalX1 = elementToAnimateInitial.x1; // Use x1 from initial state
                             const originalY1 = elementToAnimateInitial.y1;
                             const originalX2 = elementToAnimateInitial.x2; // Use x2 from initial state
                             const originalY2 = elementToAnimateInitial.y2;

                             const deltaX = currentX - originalX1;
                             const deltaY = currentY - originalY1;

                             elementToAnimateThisFrame.x1 = originalX1 + deltaX;
                             elementToAnimateThisFrame.y1 = originalY1 + deltaY;
                             elementToAnimateThisFrame.x2 = originalX2 + deltaX;
                             elementToAnimateThisFrame.y2 = originalY2 + deltaY;

                             // For drawing preview, use the updated x1/y1 for _currentRenderX/Y
                             elementToAnimateThisFrame._currentRenderX = elementToAnimateThisFrame.x1;
                             elementToAnimateThisFrame._currentRenderY = elementToAnimateThisFrame.y1;

                         } else if (elementToAnimateThisFrame.type === 'circle' || elementToAnimateThisFrame.type === 'filled-circle') {
                              // Update center (cx, cy) in the frame's copy
                              elementToAnimateThisFrame.cx = currentX;
                              elementToAnimateThisFrame.cy = currentY;
                              // Update stored x,y (top-left) based on new center for drawing/hit-testing in preview
                              elementToAnimateThisFrame.x = currentX - elementToAnimateThisFrame.radius;
                              elementToAnimateThisFrame.y = currentY - elementToAnimateThisFrame.radius;

                              // For drawing preview, use the updated cx/cy for _currentRenderX/Y
                              elementToAnimateThisFrame._currentRenderX = elementToAnimateThisFrame.cx;
                              elementToAnimateThisFrame._currentRenderY = elementToAnimateThisFrame.cy;
                         } else {
                              // Update x, y in the frame's copy (for pixel, rect, text, sprite)
                              elementToAnimateThisFrame.x = currentX;
                              elementToAnimateThisFrame.y = currentY;

                              // For drawing preview, use the updated x/y for _currentRenderX/Y
                              elementToAnimateThisFrame._currentRenderX = elementToAnimateThisFrame.x;
                              elementToAnimateThisFrame._currentRenderY = elementToAnimateThisFrame.y;
                         }


                         // Temporarily swap out the main elements array with the frame's state for drawing
                         const originalElementsRef = elements;
                         elements = currentFrameElements;
                         draw(); // Redraw the canvas for this frame
                         elements = originalElementsRef; // Swap back


                         animationFrameId = requestAnimationFrame(animate);
                    } else {
                         console.error("Animating element disappeared during animation?");
                         stopAnimationPreview();
                    }

                } else {
                    // Animation finished
                    stopAnimationPreview();
                    // The stopAnimationPreview function resets positions and redraws the static state.
                }
            }

             // Add temporary IDs if they don't exist, to find the element in the copied array
             elements.forEach(el => {
                  if (!el.id) el.id = Date.now() + Math.random();
             });
             // Store the initial positions in the animation object itself *before* starting
             const elementOriginX = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cx : selectedElement.x;
             const elementOriginY = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cy : selectedElement.y;
             selectedElement.animation.startX = elementOriginX;
             selectedElement.animation.startY = elementOriginY;


             playAnimationButton.disabled = true;
             stopAnimationButton.disabled = false;
            animationFrameId = requestAnimationFrame(animate);
         }

         function stopAnimationPreview() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                // Reset the animated element's position in the main elements array
                if (selectedElement && selectedElement.animation) {
                     // Restore the original position that was stored in the animation object
                     const originalX = selectedElement.animation.startX;
                     const originalY = selectedElement.animation.startY;

                      if (selectedElement.type === 'line') {
                          // Calculate delta from the line's *original* start point stored in the element
                          const deltaX = originalX - selectedElement.x1;
                          const deltaY = originalY - selectedElement.y1;
                          selectedElement.x1 = originalX;
                          selectedElement.y1 = originalY;
                          selectedElement.x2 += deltaX; // Move x2 by the same delta
                          selectedElement.y2 += deltaY; // Move y2 by the same delta
                      } else if (selectedElement.type === 'circle' || selectedElement.type === 'filled-circle') {
                          // Restore the center point (cx, cy)
                          selectedElement.cx = originalX;
                          selectedElement.cy = originalY;
                          // Update stored x,y (top-left) based on restored center
                          selectedElement.x = originalX - selectedElement.radius;
                          selectedElement.y = originalY - selectedElement.radius;
                      } else {
                          // Restore x, y (for pixel, rect, text, sprite)
                          selectedElement.x = originalX;
                          selectedElement.y = originalY;
                      }

                     delete selectedElement.animation.progress; // Remove progress state
                     delete selectedElement.animation.startTime; // Not used in preview, but good cleanup
                     // delete selectedElement.animation.startX; // Keep startX/startY in anim data for code generation
                     // delete selectedElement.animation.startY;
                     delete selectedElement._currentRenderX; // Clear rendering position override
                     delete selectedElement._currentRenderY;
                }
                 draw(); // Redraw to show static state
                 playAnimationButton.disabled = !selectedElement || !selectedElement.animation;
                 stopAnimationButton.disabled = true;
            }
         }


         addAnimationButton.addEventListener('click', () => {
             if (selectedElement) {
                 // Get the element's current position to store as the animation start
                 const elementOriginX = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cx : selectedElement.x;
                 const elementOriginY = selectedElement.type === 'circle' || selectedElement.type === 'filled-circle' ? selectedElement.cy : selectedElement.y;

                 selectedElement.animation = {
                     type: 'path', // Only supporting path for now
                     // Store the position *at the moment animation is added* as the animation start
                     startX: elementOriginX,
                     startY: elementOriginY,
                     endX: parseInt(animEndXInput.value) || 0, // Ensure number, default 0
                     endY: parseInt(animEndYInput.value) || 0, // Ensure number, default 0
                     steps: parseInt(animStepsInput.value) || 50 // Ensure number, default 50
                 };
                 // Assign a unique ID to the element so we can find it in copies during animation
                 if (!selectedElement.id) {
                      selectedElement.id = Date.now() + Math.random();
                 }
                 updateAnimationPanel();
                 console.log(`Animation added to element ${selectedElement.type} starting at (${selectedElement.animation.startX},${selectedElement.animation.startY})`);
             }
         });

         removeAnimationButton.addEventListener('click', () => {
             if (selectedElement && selectedElement.animation) {
                 stopAnimationPreview(); // Stop if playing
                 delete selectedElement.animation;
                 //delete selectedElement.id; // Remove ID if no longer needed? Maybe keep ID for other purposes later.
                 updateAnimationPanel();
                 console.log('Animation removed.');
             }
         });

         playAnimationButton.addEventListener('click', playAnimationPreview);
         stopAnimationButton.addEventListener('click', stopAnimationPreview);


         // --- Sprite Editor Functions ---

         function generateSpriteGrid(width, height) {
            spriteEditorGridDiv.innerHTML = '';
            spriteEditorGridDiv.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            spriteEditorGridDiv.style.width = `${width * 16}px`; // Cell size + border
            spriteEditorGridDiv.style.height = `${height * 16}px`;

            currentSpriteData = [];
            for (let y = 0; y < height; y++) {
                currentSpriteData[y] = [];
                for (let x = 0; x < width; x++) {
                    currentSpriteData[y][x] = 0; // Initialize with 0 (off)
                    const pixelDiv = document.createElement('div');
                    pixelDiv.classList.add('pixel');
                    pixelDiv.dataset.x = x;
                    pixelDiv.dataset.y = y;
                    pixelDiv.addEventListener('click', toggleSpritePixel);
                    spriteEditorGridDiv.appendChild(pixelDiv);
                }
            }
         }

         function toggleSpritePixel(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);
            if (currentSpriteData && currentSpriteData[y] !== undefined && currentSpriteData[y][x] !== undefined) {
                currentSpriteData[y][x] = 1 - currentSpriteData[y][x]; // Toggle 0 to 1, 1 to 0
                event.target.classList.toggle('on', currentSpriteData[y][x] === 1);
            }
         }

         function loadSpriteIntoEditor(spriteData, width, height) {
             spriteEditorWidthInput.value = width;
             spriteEditorHeightInput.value = height;
             generateSpriteGrid(width, height); // Re-generate grid and currentSpriteData array

             // Load pixel data into the grid divs and the currentSpriteData array
             for (let y = 0; y < height; y++) {
                 for (let x = 0; x < width; x++) {
                     // Ensure the data exists before accessing it
                     if (spriteData[y] && spriteData[y][x] === 1) {
                         const pixelDiv = spriteEditorGridDiv.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                         if (pixelDiv) {
                             pixelDiv.classList.add('on');
                             currentSpriteData[y][x] = 1; // Ensure state data is also updated
                         }
                     }
                 }
             }
         }

         function updateSpriteLibrarySelect() {
             spriteLibrarySelect.innerHTML = '<option value="">-- Load Sprite --</option>';
             for (const name in spriteLibrary) {
                 const option = document.createElement('option');
                 option.value = name;
                 option.textContent = name;
                 spriteLibrarySelect.appendChild(option);
             }
         }

         // --- Sprite Editor Event Listeners ---
         editSpriteButton.addEventListener('click', () => {
             if (selectedElement && selectedElement.type === 'sprite' && spriteLibrary[selectedElement.spriteDataRef]) {
                 const sprite = spriteLibrary[selectedElement.spriteDataRef];
                 currentSpriteName = selectedElement.spriteDataRef;
                 spriteNameInput.value = currentSpriteName;
                 currentSpriteNameSpan.textContent = currentSpriteName;
                 loadSpriteIntoEditor(sprite.data, sprite.width, sprite.height);
             } else {
                 // If no sprite element selected or sprite data missing, start a new default sprite
                 currentSpriteName = 'new_sprite';
                 spriteNameInput.value = currentSpriteName;
                 currentSpriteNameSpan.textContent = currentSpriteName;
                 generateSpriteGrid(8, 8); // Default size
             }
             spriteEditorModal.style.display = 'block';
         });

         closeModalSpan.addEventListener('click', () => {
             spriteEditorModal.style.display = 'none';
         });

         window.addEventListener('click', (event) => {
             if (event.target === spriteEditorModal) {
                 spriteEditorModal.style.display = 'none';
             }
         });

         resizeSpriteGridButton.addEventListener('click', () => {
             const width = parseInt(spriteEditorWidthInput.value);
             const height = parseInt(spriteEditorHeightInput.value);
             if (width >= 1 && width <= 32 && height >= 1 && height <= 32) {
                  // Preserve existing pixels if grid shrinks/grows
                 const oldData = currentSpriteData;
                 const oldWidth = oldData && oldData.length > 0 ? oldData[0].length : 0;
                 const oldHeight = oldData ? oldData.length : 0;

                 generateSpriteGrid(width, height); // Creates new empty grid and updates currentSpriteData

                 // Copy old data to new grid
                 if (oldData) {
                      const copyWidth = Math.min(width, oldWidth);
                      const copyHeight = Math.min(height, oldHeight);
                      for(let y = 0; y < copyHeight; y++) {
                           for(let x = 0; x < copyWidth; x++) {
                                // Check bounds for oldData
                                if (oldData[y] && oldData[y][x] === 1) {
                                    currentSpriteData[y][x] = 1;
                                     const pixelDiv = spriteEditorGridDiv.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                                     if(pixelDiv) pixelDiv.classList.add('on');
                                }
                           }
                      }
                 }

             } else {
                 alert('Sprite dimensions must be between 1 and 32.');
             }
         });

         newSpriteButton.addEventListener('click', () => {
             currentSpriteName = 'new_sprite_' + Date.now(); // Unique temp name
             spriteNameInput.value = currentSpriteName;
             currentSpriteNameSpan.textContent = currentSpriteName;
             generateSpriteGrid(8, 8); // Default size
         });

         saveSpriteButton.addEventListener('click', () => {
             let name = spriteNameInput.value.trim();
             // Sanitize name for Python variable (start with letter/underscore, followed by letter/underscore/number)
             name = name.replace(/[^a-zA-Z0-9_]/g, ''); // Remove invalid chars
             if (name.length > 0 && name.match(/^[^a-zA-Z_]/)) { // Ensure starts with letter or underscore
                 name = '_' + name;
             }
             if (!name) {
                 alert('Invalid sprite name. Please use letters, numbers, and underscores, starting with a letter or underscore.');
                 return;
             }


             const width = parseInt(spriteEditorWidthInput.value);
             const height = parseInt(spriteEditorHeightInput.value);

             if (!currentSpriteData || width <= 0 || height <= 0) {
                 alert('Sprite data is empty or dimensions are invalid.');
                 return;
             }

             // Store sprite data and dimensions
             spriteLibrary[name] = {
                 name: name,
                 width: width,
                 height: height,
                 data: JSON.parse(JSON.stringify(currentSpriteData)) // Store a deep copy
             };
             currentSpriteName = name; // Set current name to saved name
             currentSpriteNameSpan.textContent = name;
             updateSpriteLibrarySelect();
             alert(`Sprite "${name}" saved!`);

             // If the currently selected element is a sprite, update its reference if the name changed
             // Also update its dimensions displayed in the properties panel
             if (selectedElement && selectedElement.type === 'sprite') {
                 if (selectedElement.spriteDataRef !== name) {
                      selectedElement.spriteDataRef = name;
                      updatePropertiesPanel(); // Update sprite name shown in properties
                      draw(); // Redraw to reflect potential size change if loaded sprite was different size
                 } else {
                      // If saving the same sprite name that's already selected, just update the properties panel
                      // in case the sprite dimensions changed during editing.
                      updatePropertiesPanel();
                      draw(); // Redraw the canvas as the sprite's appearance might have changed
                 }
             }
         });

         loadSpriteButton.addEventListener('click', () => {
            const name = spriteLibrarySelect.value;
            if (name && spriteLibrary[name]) {
                const sprite = spriteLibrary[name];
                currentSpriteName = name;
                spriteNameInput.value = currentSpriteName;
                currentSpriteNameSpan.textContent = currentSpriteName;
                loadSpriteIntoEditor(sprite.data, sprite.width, sprite.height);
            } else if (name) {
                // Should not happen if updateSpriteLibrarySelect is called correctly, but handle it.
                 alert(`Sprite "${name}" not found in library.`);
            } else {
                alert('Please select a sprite to load.');
            }
         });


         // --- Code Generation ---

         function generateMicroPythonCode() {
            let code = `# MicroPython Code Generated by OLED UI Editor\n`;
            code += `# This code is designed to work with an SSD1306 driver library compatible with framebuf.\n`;
            code += `# e.g., https://github.com/micropython/micropython/blob/master/drivers/display/ssd1306.py\n\n`;

            code += `# IMPORTANT: You need to have the ssd1306.py library file on your Pico.\n`;
            code += `# Adjust the import and display setup below based on your connections (I2C or SPI) and pins.\n`;
            code += `# Example for I2C:\n`;
            code += `import machine\n`;
            code += `import ssd1306\n`;
            code += `import time\n`;
            code += `import framebuf # Needed for sprites\n\n`; // Added framebuf import


            code += `# Example I2C setup (adjust pins and address as needed):\n`;
            code += `# i2c = machine.I2C(0, scl=machine.Pin(1), sda=machine.Pin(0))\n`;
            code += `# display = ssd1306.SSD1306_I2C(${DISPLAY_WIDTH}, ${DISPLAY_HEIGHT}, i2c)\n\n`;
            code += `# Example for SPI (adjust pins and baudrate as needed):\n`;
            code += `# import machine\n`;
            code += `# import ssd1306\n`;
            code += `# import time\n`;
            code += `# import framebuf # Needed for sprites\n\n`; // Added framebuf import
            code += `# spi = machine.SPI(0, baudrate=10000000, polarity=0, phase=0, sck=machine.Pin(2), mosi=machine.Pin(3))\n`;
            code += `# dc = machine.Pin(4, machine.Pin.OUT)\n`;
            code += `# res = machine.Pin(5, machine.Pin.OUT)\n`;
            code += `# cs = machine.Pin(6, machine.Pin.OUT)\n`;
            code += `# display = ssd1306.SSD1306_SPI(${DISPLAY_WIDTH}, ${DISPLAY_HEIGHT}, spi, dc, res, cs)\n\n`;
            code += `# --- Choose one setup above and uncomment it ---\n\n`;


            // Generate Sprite Data
             code += `# --- Sprite Data ---\n`;
             if (Object.keys(spriteLibrary).length > 0) {
                 for (const name in spriteLibrary) {
                     const sprite = spriteLibrary[name];
                     // Ensure name is safe for Python
                     let pythonName = name.replace(/[^a-zA-Z0-9_]/g, '');
                      if (pythonName.length > 0 && pythonName.match(/^[^a-zA-Z_]/)) {
                         pythonName = '_' + pythonName;
                      }
                      if (!pythonName) {
                          code += `# WARNING: Could not generate valid Python name for sprite "${name}"\n`;
                          continue;
                      }


                     const flatData = [];
                     // Convert 2D array to byte array (assuming vertical bit packing as per framebuf.MONO_VLSB)
                     // Each byte represents 8 vertical pixels in a column
                     for (let i = 0; i < sprite.width; i++) { // Iterate columns
                         for (let j = 0; j < sprite.height; j += 8) { // Iterate down in 8-pixel chunks
                             let byte = 0;
                             for (let k = 0; k < 8; k++) {
                                 const pixelY = j + k;
                                  if (pixelY < sprite.height && sprite.data[pixelY] && sprite.data[pixelY][i] === 1) {
                                     byte |= (1 << k); // Set bit k if pixel is on
                                  }
                             }
                             flatData.push(byte);
                         }
                     }
                     code += `${pythonName}_data = bytearray([${flatData.map(b => `0x${b.toString(16).padStart(2, '0')}`).join(', ')}]) # ${sprite.width}x${sprite.height}\n`;
                 }
                 code += `\n`;
             } else {
                  code += `# No sprites defined.\n\n`;
             }


            // Generate initial elements data structure
            code += `# --- Element Definitions (Initial State) ---\n`;
            code += `elements_data = [\n`;
            elements.forEach(el => {
                code += `    {\n`;
                code += `        "type": "${el.type}",\n`;
                // Store base position (x,y or x1,y1 or cx,cy)
                 if (el.type === 'line') {
                     code += `        "x1": ${el.x1}, "y1": ${el.y1}, "x2": ${el.x2}, "y2": ${el.y2},\n`;
                 } else if (el.type === 'circle' || el.type === 'filled-circle') {
                     // Store center coordinates for circles
                     code += `        "cx": ${el.cx}, "cy": ${el.cy}, "radius": ${el.radius},\n`;
                     // Also store the top-left x,y for consistent property panel handling in the editor
                     // code += `        # editor_x: ${el.x}, editor_y: ${el.y},\n`; // Add as comment if needed for debugging
                 }
                 else {
                     // Store top-left coordinates for others
                    code += `        "x": ${el.x}, "y": ${el.y},\n`;
                 }


                // Add type-specific properties
                if (el.type === 'text') {
                    // Escape backslashes and double quotes in text
                    const escapedText = el.text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    code += `        "text": "${escapedText}",\n`;
                } else if (el.type === 'rect' || el.type === 'filled-rect') {
                    code += `        "width": ${el.width}, "height": ${el.height},\n`;
                } else if (el.type === 'sprite') {
                     const sprite = spriteLibrary[el.spriteDataRef];
                     // Sanitize name for Python variable
                     let pythonName = el.spriteDataRef.replace(/[^a-zA-Z0-9_]/g, '');
                      if (pythonName.length > 0 && pythonName.match(/^[^a-zA-Z_]/)) {
                         pythonName = '_' + pythonName;
                      }

                     if (sprite && pythonName) {
                         code += `        "spriteDataRef": ${pythonName}_data, # Reference to bytearray\n`;
                         code += `        "width": ${sprite.width}, "height": ${sprite.height}, # Sprite dimensions\n`;
                     } else {
                          code += `        # Error: Sprite data or name "${el.spriteDataRef}" not found or invalid!\n`;
                     }
                }
                 // Add common properties
                 if (el.type !== 'sprite') { // Sprites get color handled during blitting as foreground color
                     code += `        "color": ${el.color},\n`;
                 } else {
                      // Add color for sprite, which will be the foreground color for blit.
                      // The framebuf blit method uses the color parameter to specify which pixels in the source
                      // buffer (1s or 0s) are drawn using the foreground color, and which using the background.
                      // We generate MONO_VLSB data where 1s are the pixels we want to draw.
                      // The default behavior of blit(src_fb, x, y, key=-1) copies 1s from src_fb as foreground, 0s as background.
                      // If color is 0, we want the sprite's ON pixels to turn display pixels OFF (draw with background color).
                      // This requires setting a 'key' in blit. key=0 means draw 0s as foreground, 1s as background.
                      // So, if desired color is 1, key is -1 (default, draw 1s). If color is 0, key is 0 (draw 0s).
                       code += `        "color": ${el.color},\n`; # This color is used by draw_elements to determine blit key.
                 }

                if (el.type.startsWith('rect') || el.type.startsWith('circle')) {
                    code += `        "fill": ${el.fill},\n`;
                }

                 // Add animation data (if any) for the user's reference and potential use
                 if (el.animation) {
                     code += `        "animation": {\n`;
                     code += `            "type": "${el.animation.type}", # e.g., 'path'\n`;
                     // Use the stored animation start points
                     code += `            "startX": ${el.animation.startX}, "startY": ${el.animation.startY},\n`;
                     code += `            "endX": ${el.animation.endX}, "endY": ${el.animation.endY},\n`;
                     code += `            "steps": ${el.animation.steps}\n`;
                     code += `        },\n`;
                 }

                code += `    },\n`;
            });
            code += `]\n\n`;

            // Drawing function in Python
            code += `# --- Drawing Function ---\n`;
            code += `def draw_elements(display, elements):\n`;
            code += `    """Draws a list of element dictionaries onto the display buffer."""\n`;
            code += `    for el in elements:\n`;
            code += `        el_type = el["type"]\n`;
             code += `        color = el.get("color", 1) # Default color 1 if not specified\n`;
            code += `        fill = el.get("fill", False)\n\n`;
            code += `        # Get position based on element type's primary coordinates\n`;
            code += `        if el_type == "line":\n`;
            code += `            x1, y1, x2, y2 = el["x1"], el["y1"], el["x2"], el["y2"]\n`;
            code += `            display.line(x1, y1, x2, y2, color)\n`;
            code += `        elif el_type in ["rect", "filled-rect"]:\n`;
            code += `            x, y, w, h = el["x"], el["y"], el["width"], el["height"]\n`;
            code += `            if fill:\n`;
            code += `                display.fill_rect(x, y, w, h, color)\n`;
            code += `            else:\n`;
            code += `                display.rect(x, y, w, h, color)\n`;
            code += `        elif el_type in ["circle", "filled-circle"]:\n`;
             // Circles store cx, cy, radius
            code += `            cx, cy, r = el["cx"], el["cy"], el["radius"]\n`;
            code += `            # Use the circle function from the provided library which has a 'fill' parameter.\n`;
            code += `            display.circle(cx, cy, r, color, fill=fill)\n`;
            code += `        elif el_type == "text":\n`;
             // Text stores x, y (top-left)
            code += `            x, y, text_content = el["x"], el["y"], el["text"]\n`;
            code += `            display.text(text_content, x, y, color)\n`;
            code += `        elif el_type == "sprite":\n`;
             // Sprites store x, y (top-left), spriteDataRef, width, height
            code += `            x, y, sprite_data, w, h = el["x"], el["y"], el["spriteDataRef"], el["width"], el["height"]\n`;
             code += `            # Assumes your SSD1306 library has a blit method compatible with framebuf\n`;
             code += `            # Create a temporary framebuf for the sprite data.\n`;
             code += `            sprite_buf = framebuf.FrameBuffer(sprite_data, w, h, framebuf.MONO_VLSB)\n`;
             code += `            # Blit the sprite. Color is handled by the 'key' parameter in blit.\n`;
             code += `            # Default blit (key=-1) draws source 1s with foreground, 0s with background.\n`;
             code += `            # To draw source 1s with background color (color=0), use key=1.\n`;
             code += `            # The foreground/background colors for blit are set when the display object is created (usually 1 and 0).\n`;
             code += `            # Let's use the 'color' property from the element data to determine the key.\n`;
             code += `            # If el["color"] is 1 (on), use default behavior (key=-1, draws source 1s as ON pixels).\n`;
             code += `            # If el["color"] is 0 (off), use key=1 (draws source 1s as OFF pixels).\n`;
             code += `            # Note: This assumes sprite data contains the pixels that *should be changed*.\n`;
             code += `            # If sprite color is 0, we want to turn pixels OFF. Blitting with key=1 does this.\n`;
             code += `            # If sprite color is 1, we want to turn pixels ON. Blitting with key=-1 does this.\n`;
             code += `            blit_key = -1 if color == 1 else 1 # Use key=1 to blit 1s as background color (0)\n`;
             code += `            display.blit(sprite_buf, x, y, blit_key)\n`; # Pass the calculated key

             code += `        elif el_type == "pixel":\n`;
             code += `             x, y = el["x"], el["y"]\n`;
             code += `             display.pixel(x, y, color)\n`;

            code += `\n`;


            // Main execution block with animation suggestion
            code += `# --- Main Execution ---\n`;
            code += `# Define your display object before running this.\n`;
            code += `# For example: display = ssd1306.SSD1306_I2C(128, 64, i2c)\n\n`;


            code += `# Function to find an element by a property (like type, or maybe an added 'name' property)\n`;
            code += `# You might want to add a 'name' property to elements in the editor for easier reference.\n`;
            code += `# def find_element(elements_list, element_name):\n`;
            code += `#     for el in elements_list:\n`;
            code += `#         if el.get("name") == element_name:\n`;
            code += `#             return el\n`;
            code += `#     return None\n\n`;


            code += `# --- Draw Static Elements ---\n`;
            code += `# Filter elements without animation for the initial static draw\n`;
            code += `static_elements = [el for el in elements_data if "animation" not in el]\n`;
            code += `print("Drawing static elements...")\n`;
            code += `display.fill(0) # Clear the display buffer\n`;
            code += `draw_elements(display, static_elements)\n`;
            code += `display.show() # Push the buffer to the display\n`;
            code += `# time.sleep(2) # Optional: display static state for a few seconds\n\n`;


            code += `# --- Animation Loop Example (Modify as needed) ---\n`;
            code += `# This is a basic example for one animated element.\n`;
            code += `# For multiple animations or more complex timing, you'll need a more advanced loop.\n`;
            code += `# Find elements with animation data\n`;
            code += `animated_elements = [el for el in elements_data if "animation" in el]\n\n`;

            code += `# if animated_elements:\n`;
            code += `#     print(f"Starting animation for {len(animated_elements)} element(s)...")\n`;
            code += `#     # Keep track of current state for animated elements\n`;
            code += `#     current_animated_state = {el["id"]: {"x": el["animation"]["startX"], "y": el["animation"]["startY"], "progress": 0} for el in animated_elements if "id" in el}\n`; # Assumes 'id' was added in editor


            code += `#     # Animation loop\n`;
            code += `#     total_animation_steps = max([el["animation"]["steps"] for el in animated_elements]) if animated_elements else 0\n`; # Find max steps if animating multiple

            code += `#     for step in range(total_animation_steps + 1):\n`;
            code += `#         display.fill(0) # Clear the previous frame\n`;

            code += `#         # Redraw static elements\n`;
            code += `#         draw_elements(display, static_elements)\n`;

            code += `#         # Draw animated elements at their current step position\n`;
            code += `#         for el in animated_elements:\n`;
            code += `#             anim = el["animation"]\n`;
            code += `#             # Calculate current step for this specific element (if needed, or just use global step)\n`;
            code += `#             # For simple linear animation across total_animation_steps:\n`;
            code += `#             current_step_for_el = min(step, anim["steps"]) # Cap at element's total steps\n`;

            code += `#             # Calculate interpolated position\n`;
            code += `#             # Ensure division by zero is handled if steps is 0 (editor prevents this, but good practice)\n`;
            code += `#             progress = current_step_for_el / anim["steps"] if anim["steps"] > 0 else 1\n`;
            code += `#             current_x = int(anim["startX"] + (anim["endX"] - anim["startX"]) * progress)\n`;
            code += `#             current_y = int(anim["startY"] + (anim["endY"] - anim["startY"]) * progress)\n`;

            code += `#             # Create a temporary element dictionary for drawing at the current position\n`;
            code += `#             # This avoids modifying the original elements_data list during animation\n`;
            code += `#             temp_el = dict(el) # Create a copy\n`;

            code += `#             # Update position properties in the temporary dictionary\n`;
            code += `#             if temp_el["type"] == "line":\n`;
            code += `#                 # Move both points relative to the stored animation start (which was the line's initial x1, y1)\n`;
            code += `#                 # Need the original line's x1, y1, x2, y2 from the elements_data list (or initial state)\n`;
            code += `#                 # Finding original points requires referencing the element from the elements_data list that hasn't been position-modified in the loop.\n`;
            code += `#                 # A better approach might be to store original geometry in the animation dict or use indices.\n`;
            code += `#                 # Simplified: Assuming anim["startX"], anim["startY"] were the *original* x1, y1:\n`;
            code += `#                 original_x1 = anim["startX"]\n`;
            code += `#                 original_y1 = anim["startY"]\n`;
            code += `#                 # You would need original x2, y2 here. Let's assume they are in the original 'el' dict before modification.\n`;
            code += `#                 # This animation structure needs original geometry accessible inside the loop.\n`;
            code += `#                 # Let's add original geometry to animation data during generation for clarity.\n`;
            code += `#                 original_x2 = anim.get("original_x2", el.get("x2")) # Need to add original_x2 to anim data\n`;
            code += `#                 original_y2 = anim.get("original_y2", el.get("y2")) # Need to add original_y2 to anim data\n`;
            code += `#                 dx = current_x - original_x1\n`;
            code += `#                 dy = current_y - original_y1\n`;
            code += `#                 temp_el["x1"] = original_x1 + dx\n`;
            code += `#                 temp_el["y1"] = original_y1 + dy\n`;
            code += `#                 if original_x2 is not None and original_y2 is not None:\n`;
            code += `#                     temp_el["x2"] = original_x2 + dx\n`;
            code += `#                     temp_el["y2"] = original_y2 + dy\n`;
            code += `#             elif temp_el["type"] in ["circle", "filled-circle"]:\n`;
            code += `#                 # Update center (cx, cy)\n`;
            code += `#                 temp_el["cx"] = current_x\n`;
            code += `#                 temp_el["cy"] = current_y\n`;
            code += `#                 # Update stored x,y (top-left) based on new center for drawing function (it uses cx, cy anyway)\n`;
            code += `#                 temp_el["x"] = current_x - temp_el["radius"]\n`;
            code += `#                 temp_el["y"] = current_y - temp_el["radius"]\n`;
            code += `#             else:\n`;
            code += `#                 # Update x, y (for pixel, rect, text, sprite)\n`;
            code += `#                 temp_el["x"] = current_x\n`;
            code += `#                 temp_el["y"] = current_y\n`;

            code += `#             # Draw the element at its temporary animated position\n`;
            code += `#             draw_elements(display, [temp_el]) # Draw this single element\n`;

            code += `#         display.show() # Update the display\n`;
            code += `#         #time.sleep(0.05) # Add a small delay (e.g., ~20 FPS)\n`;
            code += `# else:\n`;
            code += `#     print("No animated elements found.")\n`;


            code += `print("Code execution finished.")\n`;


            generatedCodePre.textContent = code;
         }


         generateCodeButton.addEventListener('click', generateMicroPythonCode);


        // --- Initialization ---
        function initialize() {
            // Scale canvas for better visibility in browser
            canvas.style.width = `${DISPLAY_WIDTH * SCALE}px`;
            canvas.style.height = `${DISPLAY_HEIGHT * SCALE}px`;

            // Load some predefined sprites
            spriteLibrary = {
                 "smiley": {
                     name: "smiley", width: 8, height: 8,
                     data: [
                         [0,1,1,1,1,1,1,0],
                         [1,0,0,0,0,0,0,1],
                         [1,0,1,0,0,1,0,1],
                         [1,0,0,0,0,0,0,1],
                         [1,0,1,0,0,1,0,1],
                         [1,0,0,1,1,0,0,1],
                         [1,0,0,0,0,0,0,1],
                         [0,1,1,1,1,1,1,0]
                     ]
                 },
                 "heart": {
                    name: "heart", width: 7, height: 7,
                    data: [
                         [0,0,1,0,1,0,0],
                         [0,1,1,1,1,1,0],
                         [1,1,1,1,1,1,1],
                         [1,1,1,1,1,1,1],
                         [0,1,1,1,1,1,0],
                         [0,0,1,1,1,0,0],
                         [0,0,0,1,0,0,0]
                    ]
                 }
             };
            updateSpriteLibrarySelect(); // Populate sprite library dropdown

            // Initial draw
            draw();
            updatePropertiesPanel(); // Hide properties panel initially
            updateElementList(); // Populate element list
        }

         // Run initialization when the DOM is ready
        document.addEventListener('DOMContentLoaded', initialize);


    </script>

</body>
</html>
